lines(rectangles, d_plot[,"pa1"], col = "tan")
source(here("functions/gpedagocial-learner.R"))
source(here("functions/pedagocial-learner.R"))
source(here("functions/alphaGridDist.R"))
source(here("functions/pedagocial-learner.R"))
knitr::opts_chunk$set(echo = TRUE)
library(here)
source(here("functions/generic-functions.R"))
source(here("functions/alphaGridDist.R"))
source(here("functions/pedagocial-learner.R"))
source(here("functions/pedagogical-learner.R"))
knitr::opts_chunk$set(echo = TRUE)
library(here)
source(here("functions/generic-functions.R"))
source(here("functions/alphaGridDist.R"))
source(here("functions/pedagogical-learner.R"))
d_plot[25,]
rect = d_plot[25,]
source(here("functions/optimiseAlpha.R"))
fitAlpha(partRectangle = rect, gridDist)
fit =fitAlpha(partRectangle = rect, gridDist)
View(fit)
grid = alphaGridSearch(borders,obs)
fit =fitAlpha(partRectangle = rect, gridSearch = grid)
View(fit)
rect = d_plot[25,1:4]
fit =fitAlpha(partRectangle = rect, gridSearch = grid)
rect
class(rect)
View(fit)
debugonce(fitAlpha)
fit =fitAlpha(partRectangle = rect, gridSearch = grid)
View(partRectangle)
fit = fitAlpha(partRectangle = as.matrix(rect), gridSearch = grid)
View(grid)
alphaProbs = gridDist[gridDist[1,]==rect[1] & gridDist[2,]==rect[2] & gridDist[3,]==rect[3] & gridDist[4,]==rect[4],]
rect[1]
rect[2]
rect[3]
alphaProbs = gridDist[c(gridDist[1,]==rect[1] & gridDist[2,]==rect[2] & gridDist[3,]==rect[3] & gridDist[4,]==rect[4]),]
gridDist[gridDist[1,]==rect[1],]
alphaProbs = gridDist[c(gridDist[,1]==rect[1] & gridDist[,1]==rect[2] & gridDist[,1]==rect[3] & gridDist[,4]==rect[4]),]
pedLearner(borders, obs, alpha = 0.8)
learner.8 = pedLearner(borders, obs, alpha = 0.8)
learner.8
View(learner.8)
leraner1 = pedLearner(borders, obs, alpha = 1)
View(leraner1)
# make rectangle grid (borders)
borders = makeBorders(0:3)
source("~/Documents/Projects/RectangleWorld-sims/functions/generic-functions.R")
source("~/Documents/Projects/RectangleWorld-sims/functions/pedagogical-learner.R")
#' Simulates a learner who assumes observations are sampled pedagogically
#'
#' @param alpha Numeric value from -inf to inf. determines how helpful the learner thinks the teacher is. Alpha = 0 is equivalent to weak sampling, alpha = 1 is standard pedagogical sampling.
#' @param borders Array of hypothesised category boundary points (coordinates of rectangles)
#' @param observations Points that have been labelled as belonging to a certain category
#' @param prior Numeric vector of the same length as borders. Default is a uniform prior.
pedLearner = function(borders, observations, borderSize = 100, prior = "uniform", alpha = 1) {
# set up default prior if no other is specified
prior = ifelse(prior == "uniform", rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))), prior)
# Rule out ineligible rectangles ----------------------------------------------------------------------
posInRect = areInCat(borders, observations, "positive")
if (is.na(posInRect[1])) {
hasPosEvidence = rep(TRUE,length(borders[,1])) # if there is no positive evidence, then all of the hypotheses are valid for this condition
} else { f = function(isInRect) setequal(isInRect, rep(TRUE, length(as.data.frame(isInRect)))) # make isInRect a function suitable for apply
# Find out which rectangles contain positive evidence
hasPosEvidence = if (length(as.data.frame(posInRect)) > 1) {
apply(posInRect, 1, f)
} else {
# if length is 1, no need to do the above function
hasPosEvidence = posInRect
}
}
negInRect = areInCat(borders, observations, "negative") # does the hypothesised rectangle contain negative evidence?
if (is.na(negInRect[1])) {
hasNegEvidence =  rep(FALSE,length(borders[,1]))
} else {
hasNegEvidence = if (length(as.data.frame(negInRect)) > 1) {
hasNegEvidence = rowSums(negInRect) > 0
} else {
hasNegEvidence = negInRect
}
}
hypotheses = cbind(borders, hasPosEvidence, hasNegEvidence)
hypotheses = hypotheses[hypotheses[, "hasPosEvidence"] == TRUE &
hypotheses[, "hasNegEvidence"] == FALSE, ]
# Pedagogical likelihood --------------------------------------------------------------------------------------------
# Calculate the number of positive and negative observations
if (is.vector(observations)){
numPos = sum(observations["category"]=="positive")
numNeg = sum(observations["category"]=="negative")
} else {
numPos = sum(observations[,"category"]=="positive")
numNeg = sum(observations[,"category"]=="negative")
}
# calculate the area outside of each prospective rectangle (hypothesis)
sizeNeg = findSizeNeg(hypotheses, borderSize = borderSize)
# calculate the area inside of each prospective rectangle (hypothesis)
sizePos = findSize(hypotheses)
# calculate the likelihood of positive and negative evidence respectively
likelihoodNeg = (1 / sizeNeg^ numNeg)
likelihoodPos = (1 / sizePos^ numPos) # non-log probability so that I can integrate it with alpha/transparency when plotting
likelihood = (likelihoodNeg*likelihoodPos)^alpha
posterior = (likelihood*prior)/sum(likelihood*prior)
logLikelihood = log(likelihood)
pedHypotheses = cbind(hypotheses[,1:6], sizePos,sizeNeg,prior,likelihood, likelihoodPos, likelihoodNeg,logLikelihood,posterior)
colnames(pedHypotheses) = c( # <-- matrix columns messed up
"x1",
"y1",
"x2",
"y2",
"hasPosEvidence",
"hasNegEvidence",
"sizePos",
"sizeNeg",
"prior",
"likelihood",
"likelihoodPos",
"likelihoodNeg",
"logLikelihood",
"posterior"
)
return(pedHypotheses)
}
knitr::opts_chunk$set(echo = TRUE)
library(here)
library(ggplot2)
source(here("functions/generic-functions.R"))
source(here("functions/samplingFunctions.R"))
source(here("functions/fit-multi-trial.R"))
source(here("functions/optimiseAlpha.R"))
source(here("functions/pedagogical-learner.R"))
# make rectangle grid (borders)
borders = makeBorders(0:10)
# generate true rectangles
rect1 = genTrueRects(1, borders)
# generate observations
obs = generateObs(c(1,1,2,2), c(0,1,1,2), as.vector(rect1))
# simulate multiple trials of responses
partTrust = cbind(simulate_MultiTrials(obs, alpha = 1), alpha = 1)
# generate true rectangles
rect1 = genTrueRects(1, borders)
# generate observations
obs = generateObs(c(1,1,2,2), c(0,1,1,2), as.vector(rect1))
# make rectangle grid (borders)
borders = makeBorders(0:10)
# generate true rectangles
rect1 = genTrueRects(1, borders)
# generate observations
obs = generateObs(c(1,1,2,2), c(0,1,1,2), as.vector(rect1))
# simulate multiple trials of responses
partTrust = cbind(simulate_MultiTrials(obs, alpha = 1), alpha = 1)
pedLearner(borders, obs)
# simulate multiple trials of responses
debugonce(pedLearner)
pedLearner(borders, obs)
debugonce(pedLearner)
pedLearner(borders, obs)
pedLearner(borders, obs)
source("~/Documents/Projects/RectangleWorld-sims/functions/generic-functions.R")
pedLearner(borders, obs)
partTrust = cbind(simulate_MultiTrials(obs, alpha = 1), alpha = 1)
# simulate multiple trials of responses
partTrust = cbind(simulate_MultiTrials(obs, alpha = 1), alpha = 1)
partDecept = cbind(simulate_MultiTrials(obs, alpha = -1), alpha = -1)
partWeak =  cbind(simulate_MultiTrials(obs, alpha = 0), alpha = 0)
# plot
d_plot = rbind(partTrust, partWeak, partDecept)
ggplot(data = (as.data.frame(d_plot)))+
geom_point(data = as.data.frame(obs), aes(as.numeric(x),as.numeric(y)))+
geom_rect(aes(xmin = x1, xmax = x2, ymin = y1, ymax = y2),colour = "black", alpha = 0)+
facet_grid(alpha ~ nObsCond)
## Test pedagogical model
load("obsTest.Rdata")
obs1 = obs[obs[,"nObsCond"] == 1,]
obs2 = obs[obs[,"nObsCond"] == 2,]
borders = makeBorders(0:10)
l1 = pedLearner(borders, obs1)
l2 = pedLearner(borders, obs2)
View(l1)
View(l2)
sum(l2[,"likelihoodNeg"])
sum(l2[,"likelihoodPos"])
rect = c(2,2,4,4)
findSize(rect)
findSizeNeg(rect)
findSizeNeg(rect, 100)
rect1 = c(0,0,10,10)
findSize(rect1)
findSizeNeg(rect1)
findSizeNeg(rect1, 100)
sum(obs[,"category"] == "negative")
sum(obs[,"category"] == "positive")
sum(obs2[,"category"] == "positive")
0.02*0.98
#' Simulates a learner who assumes observations are sampled pedagogically
#'
#' @param alpha Numeric value from -inf to inf. determines how helpful the learner thinks the teacher is. Alpha = 0 is equivalent to weak sampling, alpha = 1 is standard pedagogical sampling.
#' @param borders Array of hypothesised category boundary points (coordinates of rectangles)
#' @param observations Points that have been labelled as belonging to a certain category
#' @param prior Numeric vector of the same length as borders. Default is a uniform prior.
pedLearner = function(borders, observations, borderSize = 100, prior = "uniform", alpha = 1) {
# set up default prior if no other is specified
prior = ifelse(prior == "uniform", rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))), prior)
# Rule out ineligible rectangles ----------------------------------------------------------------------
posInRect = areInCat(borders, observations, "positive")
if (is.na(posInRect[1])) {
hasPosEvidence = rep(TRUE,length(borders[,1])) # if there is no positive evidence, then all of the hypotheses are valid for this condition
} else { f = function(isInRect) setequal(isInRect, rep(TRUE, length(as.data.frame(isInRect)))) # make isInRect a function suitable for apply
# Find out which rectangles contain positive evidence
hasPosEvidence = if (length(as.data.frame(posInRect)) > 1) {
apply(posInRect, 1, f)
} else {
# if length is 1, no need to do the above function
hasPosEvidence = posInRect
}
}
negInRect = areInCat(borders, observations, "negative") # does the hypothesised rectangle contain negative evidence?
if (is.na(negInRect[1])) {
hasNegEvidence =  rep(FALSE,length(borders[,1]))
} else {
hasNegEvidence = if (length(as.data.frame(negInRect)) > 1) {
hasNegEvidence = rowSums(negInRect) > 0
} else {
hasNegEvidence = negInRect
}
}
hypotheses = cbind(borders, hasPosEvidence, hasNegEvidence)
hypotheses = hypotheses[hypotheses[, "hasPosEvidence"] == TRUE &
hypotheses[, "hasNegEvidence"] == FALSE, ]
# Pedagogical likelihood --------------------------------------------------------------------------------------------
# Calculate the number of positive and negative observations
if (is.vector(observations)){
numPos = sum(observations["category"]=="positive")
numNeg = sum(observations["category"]=="negative")
} else {
numPos = sum(observations[,"category"]=="positive")
numNeg = sum(observations[,"category"]=="negative")
}
# calculate the area outside of each prospective rectangle (hypothesis)
sizeNeg = findSizeNeg(hypotheses, borderSize = borderSize)
# calculate the area inside of each prospective rectangle (hypothesis)
sizePos = findSize(hypotheses)
# calculate the likelihood of positive and negative evidence respectively
likelihoodNeg = (1 / sizeNeg^ numNeg)
likelihoodPos = (1 / sizePos^ numPos) # non-log likelihood so that I can integrate it with alpha/transparency when plotting
likelihood = (likelihoodNeg*likelihoodPos)^alpha
posterior = (likelihood*prior)/sum(likelihood*prior)
logLikelihood = log(likelihood)
pedHypotheses = cbind(hypotheses[,1:4], sizePos,sizeNeg,prior,likelihood, likelihoodPos, likelihoodNeg,logLikelihood,posterior)
colnames(pedHypotheses) = c( # <-- rename cols
"x1",
"y1",
"x2",
"y2",
"sizePos",
"sizeNeg",
"prior",
"likelihood",
"likelihoodPos",
"likelihoodNeg",
"logLikelihood",
"posterior"
)
return(pedHypotheses)
}
debugonce(pedLearner)
l2 = pedLearner(borders, obs2)
View(sizeNeg)
View(likelihoodNeg)
#' Simulates a learner who assumes observations are sampled pedagogically
#'
#' @param alpha Numeric value from -inf to inf. determines how helpful the learner thinks the teacher is. Alpha = 0 is equivalent to weak sampling, alpha = 1 is standard pedagogical sampling.
#' @param borders Array of hypothesised category boundary points (coordinates of rectangles)
#' @param observations Points that have been labelled as belonging to a certain category
#' @param prior Numeric vector of the same length as borders. Default is a uniform prior.
pedLearner = function(borders, observations, borderSize = 100, prior = "uniform", alpha = 1) {
# set up default prior if no other is specified
prior = ifelse(prior == "uniform", rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))), prior)
# Rule out ineligible rectangles ----------------------------------------------------------------------
posInRect = areInCat(borders, observations, "positive")
if (is.na(posInRect[1])) {
hasPosEvidence = rep(TRUE,length(borders[,1])) # if there is no positive evidence, then all of the hypotheses are valid for this condition
} else { f = function(isInRect) setequal(isInRect, rep(TRUE, length(as.data.frame(isInRect)))) # make isInRect a function suitable for apply
# Find out which rectangles contain positive evidence
hasPosEvidence = if (length(as.data.frame(posInRect)) > 1) {
apply(posInRect, 1, f)
} else {
# if length is 1, no need to do the above function
hasPosEvidence = posInRect
}
}
negInRect = areInCat(borders, observations, "negative") # does the hypothesised rectangle contain negative evidence?
if (is.na(negInRect[1])) {
hasNegEvidence =  rep(FALSE,length(borders[,1]))
} else {
hasNegEvidence = if (length(as.data.frame(negInRect)) > 1) {
hasNegEvidence = rowSums(negInRect) > 0
} else {
hasNegEvidence = negInRect
}
}
hypotheses = cbind(borders, hasPosEvidence, hasNegEvidence)
hypotheses = hypotheses[hypotheses[, "hasPosEvidence"] == TRUE &
hypotheses[, "hasNegEvidence"] == FALSE, ]
# Pedagogical likelihood --------------------------------------------------------------------------------------------
# Calculate the number of positive and negative observations
if (is.vector(observations)){
numPos = sum(observations["category"]=="positive")
numNeg = sum(observations["category"]=="negative")
} else {
numPos = sum(observations[,"category"]=="positive")
numNeg = sum(observations[,"category"]=="negative")
}
# calculate the area outside of each prospective rectangle (hypothesis)
sizeNeg = findSizeNeg(hypotheses, borderSize = borderSize)
# calculate the area inside of each prospective rectangle (hypothesis)
sizePos = findSize(hypotheses)
# calculate the likelihood of positive and negative evidence respectively
likelihoodNeg = (1 / sizeNeg^ numNeg)
likelihoodPos = (1 / sizePos^ numPos) # non-log likelihood so that I can integrate it with alpha/transparency when plotting
likelihood = (likelihoodNeg+likelihoodPos)^alpha
posterior = (likelihood*prior)/sum(likelihood*prior)
logLikelihood = log(likelihood)
pedHypotheses = cbind(hypotheses[,1:4], sizePos,sizeNeg,prior,likelihood, likelihoodPos, likelihoodNeg,logLikelihood,posterior)
colnames(pedHypotheses) = c( # <-- rename cols
"x1",
"y1",
"x2",
"y2",
"sizePos",
"sizeNeg",
"prior",
"likelihood",
"likelihoodPos",
"likelihoodNeg",
"logLikelihood",
"posterior"
)
return(pedHypotheses)
}
plot(obs2)
plot(obs2, xlim = c(0:10), ylim = c(0:10))
plot(obs2, xlim = c(0,10), ylim = c(0,10))
l2 = pedLearner(borders, obs2)
View(l2)
rect(6,2,7,3)
obs2 = rbind(c(x = 2, y = 2,category = "positive"), c(x = 8, y = 8, category = "negative"))
obs2
l2 = pedLearner(borders, obs2)
plot(obs2, xlim = c(0,10), ylim = c(0,10))
rect()
View(l2)
rect(1,1,2,2)
#' Simulates a learner who assumes observations are sampled pedagogically
#'
#' @param alpha Numeric value from -inf to inf. determines how helpful the learner thinks the teacher is. Alpha = 0 is equivalent to weak sampling, alpha = 1 is standard pedagogical sampling.
#' @param borders Array of hypothesised category boundary points (coordinates of rectangles)
#' @param observations Points that have been labelled as belonging to a certain category
#' @param prior Numeric vector of the same length as borders. Default is a uniform prior.
pedLearner = function(borders, observations, borderSize = 100, prior = "uniform", alpha = 1) {
# set up default prior if no other is specified
prior = ifelse(prior == "uniform", rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))), prior)
# Rule out ineligible rectangles ----------------------------------------------------------------------
posInRect = areInCat(borders, observations, "positive")
if (is.na(posInRect[1])) {
hasPosEvidence = rep(TRUE,length(borders[,1])) # if there is no positive evidence, then all of the hypotheses are valid for this condition
} else { f = function(isInRect) setequal(isInRect, rep(TRUE, length(as.data.frame(isInRect)))) # make isInRect a function suitable for apply
# Find out which rectangles contain positive evidence
hasPosEvidence = if (length(as.data.frame(posInRect)) > 1) {
apply(posInRect, 1, f)
} else {
# if length is 1, no need to do the above function
hasPosEvidence = posInRect
}
}
negInRect = areInCat(borders, observations, "negative") # does the hypothesised rectangle contain negative evidence?
if (is.na(negInRect[1])) {
hasNegEvidence =  rep(FALSE,length(borders[,1]))
} else {
hasNegEvidence = if (length(as.data.frame(negInRect)) > 1) {
hasNegEvidence = rowSums(negInRect) > 0
} else {
hasNegEvidence = negInRect
}
}
hypotheses = cbind(borders, hasPosEvidence, hasNegEvidence)
hypotheses = hypotheses[hypotheses[, "hasPosEvidence"] == TRUE &
hypotheses[, "hasNegEvidence"] == FALSE, ]
# Pedagogical likelihood --------------------------------------------------------------------------------------------
# Calculate the number of positive and negative observations
if (is.vector(observations)){
numPos = sum(observations["category"]=="positive")
numNeg = sum(observations["category"]=="negative")
} else {
numPos = sum(observations[,"category"]=="positive")
numNeg = sum(observations[,"category"]=="negative")
}
# calculate the area outside of each prospective rectangle (hypothesis)
sizeNeg = findSizeNeg(hypotheses, borderSize = borderSize)
# calculate the area inside of each prospective rectangle (hypothesis)
sizePos = findSize(hypotheses)
# calculate the likelihood of positive and negative evidence respectively
likelihoodNeg = (1 / sizeNeg^ numNeg)/sum((1 / sizeNeg^ numNeg))
likelihoodPos = (1 / sizePos^ numPos)/sum((1 / sizePos^ numPos)) # non-log likelihood so that I can integrate it with alpha/transparency when plotting
likelihood = (likelihoodNeg*likelihoodPos)^alpha
posterior = (likelihood*prior)/sum(likelihood*prior)
logLikelihood = log(likelihood)
pedHypotheses = cbind(hypotheses[,1:4], sizePos,sizeNeg,prior,likelihood, likelihoodPos, likelihoodNeg,logLikelihood,posterior)
colnames(pedHypotheses) = c( # <-- rename cols
"x1",
"y1",
"x2",
"y2",
"sizePos",
"sizeNeg",
"prior",
"likelihood",
"likelihoodPos",
"likelihoodNeg",
"logLikelihood",
"posterior"
)
return(pedHypotheses)
}
l2 = pedLearner(borders, obs2)
plot(obs2, xlim = c(0,10), ylim = c(0,10))
rect(1,1,2,2)
plot(obs2, xlim = c(0,10), ylim = c(0,10))
View(l2)
c(1,1,2,2)
c(1,1,2,2)rect(1,1,2,2)
rect(1,1,2,2)
obs2 = rbind(c(x = 2.5, y = 2.5,category = "positive"), c(x = 8.5, y = 8.5, category = "negative"))
# calculate the likelihood of positive and negative evidence respectively
likelihoodNeg = (1 / sizeNeg^ numNeg)/sum((1 / sizeNeg^ numNeg))
likelihoodPos = (1 / sizePos^ numPos)/sum((1 / sizePos^ numPos)) # non-log likelihood so that I can integrate it with alpha/transparency when plotting
#' Simulates a learner who assumes observations are sampled pedagogically
#'
#' @param alpha Numeric value from -inf to inf. determines how helpful the learner thinks the teacher is. Alpha = 0 is equivalent to weak sampling, alpha = 1 is standard pedagogical sampling.
#' @param borders Array of hypothesised category boundary points (coordinates of rectangles)
#' @param observations Points that have been labelled as belonging to a certain category
#' @param prior Numeric vector of the same length as borders. Default is a uniform prior.
pedLearner = function(borders, observations, borderSize = 100, prior = "uniform", alpha = 1) {
# set up default prior if no other is specified
prior = ifelse(prior == "uniform", rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))), prior)
# Rule out ineligible rectangles ----------------------------------------------------------------------
posInRect = areInCat(borders, observations, "positive")
if (is.na(posInRect[1])) {
hasPosEvidence = rep(TRUE,length(borders[,1])) # if there is no positive evidence, then all of the hypotheses are valid for this condition
} else { f = function(isInRect) setequal(isInRect, rep(TRUE, length(as.data.frame(isInRect)))) # make isInRect a function suitable for apply
# Find out which rectangles contain positive evidence
hasPosEvidence = if (length(as.data.frame(posInRect)) > 1) {
apply(posInRect, 1, f)
} else {
# if length is 1, no need to do the above function
hasPosEvidence = posInRect
}
}
negInRect = areInCat(borders, observations, "negative") # does the hypothesised rectangle contain negative evidence?
if (is.na(negInRect[1])) {
hasNegEvidence =  rep(FALSE,length(borders[,1]))
} else {
hasNegEvidence = if (length(as.data.frame(negInRect)) > 1) {
hasNegEvidence = rowSums(negInRect) > 0
} else {
hasNegEvidence = negInRect
}
}
hypotheses = cbind(borders, hasPosEvidence, hasNegEvidence)
hypotheses = hypotheses[hypotheses[, "hasPosEvidence"] == TRUE &
hypotheses[, "hasNegEvidence"] == FALSE, ]
# Pedagogical likelihood --------------------------------------------------------------------------------------------
# Calculate the number of positive and negative observations
if (is.vector(observations)){
numPos = sum(observations["category"]=="positive")
numNeg = sum(observations["category"]=="negative")
} else {
numPos = sum(observations[,"category"]=="positive")
numNeg = sum(observations[,"category"]=="negative")
}
# calculate the area outside of each prospective rectangle (hypothesis)
sizeNeg = findSizeNeg(hypotheses, borderSize = borderSize)
# calculate the area inside of each prospective rectangle (hypothesis)
sizePos = findSize(hypotheses)
# calculate the likelihood of positive and negative evidence respectively
likelihoodNeg = (1 / sizeNeg^ numNeg)/sum((1 / sizeNeg^ numNeg))
likelihoodPos = (1 / sizePos^ numPos)/sum((1 / sizePos^ numPos)) # non-log likelihood so that I can integrate it with alpha/transparency when plotting
likelihood = (likelihoodNeg*likelihoodPos)^alpha
posterior = (likelihood*prior)/sum(likelihood*prior)
logLikelihood = log(likelihood)
pedHypotheses = cbind(hypotheses[,1:4], sizePos,sizeNeg,prior,likelihood, likelihoodPos, likelihoodNeg,logLikelihood,posterior)
colnames(pedHypotheses) = c( # <-- rename cols
"x1",
"y1",
"x2",
"y2",
"sizePos",
"sizeNeg",
"prior",
"likelihood",
"likelihoodPos",
"likelihoodNeg",
"logLikelihood",
"posterior"
)
return(pedHypotheses)
}
source("~/Documents/Projects/RectangleWorld-sims/functions/pedagogical-learner.R")
l2 = pedLearner(borders, obs2)
View(l2)
