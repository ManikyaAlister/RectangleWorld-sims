nRectangles = 1
obs1 = generateObs(nPos, nNeg, 1, trueRects)
#'
#' @param alphaRange vector of alpha values you want to search
#' @param borders entire range of possible rectangles
#' @param observations 3-columned labeled matrix of points provided by the teacher
#' @param prior prior probability of each rectangle
#'
#' @return 5 by length(alphaRange) array with rectangle coordinates and the alpha that generated those coordinates in each row.
#' @export
#'
#' @examples
alphaGridSearch = function(borders,
observations,
alphaRange = seq(from = -1, to = 1, by = .2),
prior = "uniform") {r
gridSearch = array(NA, dim = c(length(alphaRange), 4)) # create an empty array to fill with the coordinates of each rectangle predicted by a given alpha.
for (i in 1:length(alphaRange)) {
rect =  pedLearner(borders, observations, prior, alpha = alphaRange[i]) # generate all eligible rectangles (hypotheses)
orderedRect =  order(rect[, "posterior"], decreasing = TRUE) # order from highest to lowest probability
bestRect = as.numeric(rect[orderedRect[1], 1:4]) # take the most probable rectangle, keeping only the coordinate information (columns 1:4)
gridSearch[i,] = bestRect # fill relevant row with the rectangle for that alpha
}
gridSearch = cbind(gridSearch, alphaRange) # add a column so we know what alpha generated each rectangle
colnames(gridSearch) = c("x1", "y1", "x2", "y2", "alpha") # name
return(gridSearch)
}
obs1
alphaGridSearch(borders, obs1[,1:3])
obs1 = generateObs(nPos, nNeg, 1, trueRects)
alphaGridSearch(borders, obs1[,1:3])
debugonce(alphaGridSearch)
debugonce(alphaGridSearch)
alphaGridSearch(borders, obs1[,1:3])
#'
#' @param alphaRange vector of alpha values you want to search
#' @param borders entire range of possible rectangles
#' @param observations 3-columned labeled matrix of points provided by the teacher
#' @param prior prior probability of each rectangle
#'
#' @return 5 by length(alphaRange) array with rectangle coordinates and the alpha that generated those coordinates in each row.
#' @export
#'
#' @examples
alphaGridSearch = function(borders,
observations,
alphaRange = seq(from = -1, to = 1, by = .2),
prior = "uniform") {
gridSearch = array(NA, dim = c(length(alphaRange), 4)) # create an empty array to fill with the coordinates of each rectangle predicted by a given alpha.
for (i in 1:length(alphaRange)) {
rect =  pedLearner(borders, observations, prior, alpha = alphaRange[i]) # generate all eligible rectangles (hypotheses)
orderedRect =  order(rect[, "posterior"], decreasing = TRUE) # order from highest to lowest probability
bestRect = as.numeric(rect[orderedRect[1], 1:4]) # take the most probable rectangle, keeping only the coordinate information (columns 1:4)
gridSearch[i,] = bestRect # fill relevant row with the rectangle for that alpha
}
gridSearch = cbind(gridSearch, alphaRange) # add a column so we know what alpha generated each rectangle
colnames(gridSearch) = c("x1", "y1", "x2", "y2", "alpha") # name
return(gridSearch)
}
alphaGridSearch(borders, obs1[,1:3])
debugonce(alphaGridSearch)
alphaGridSearch(borders, obs1[,1:3])
View(rect)
View(rect)
observations = obs1
gridSearch = array(NA, dim = c(length(alphaRange), 4)) # create an empty array to fill with the coordinates of each rectangle predicted by a given alpha.
#'
#' @param alphaRange vector of alpha values you want to search
#' @param borders entire range of possible rectangles
#' @param observations 3-columned labeled matrix of points provided by the teacher
#' @param prior prior probability of each rectangle
#'
#' @return 5 by length(alphaRange) array with rectangle coordinates and the alpha that generated those coordinates in each row.
#' @export
#'
#' @examples
alphaGridSearch = function(borders,
observations,
alphaRange = seq(from = -1, to = 1, by = .2),
prior = "uniform") {
gridSearch = array(NA, dim = c(length(alphaRange), 4)) # create an empty array to fill with the coordinates of each rectangle predicted by a given alpha.
for (i in 1:length(alphaRange)) {
rect =  pedLearner(borders, observations, prior, alpha = alphaRange[i]) # generate all eligible rectangles (hypotheses)
orderedRect =  order(rect[, "posterior"], decreasing = TRUE) # order from highest to lowest probability
bestRect = as.numeric(rect[rect[,posterior == rect[orderedRect[1], posterior]], 1:4]) # take the most probable rectangle, keeping only the coordinate information (columns 1:4)
gridSearch[i,] = bestRect # fill relevant row with the rectangle for that alpha
}
gridSearch = cbind(gridSearch, alphaRange) # add a column so we know what alpha generated each rectangle
colnames(gridSearch) = c("x1", "y1", "x2", "y2", "alpha") # name
return(gridSearch)
}
prior = "uniform"
gridSearch = array(NA, dim = c(length(alphaRange), 4)) # create an empty array to fill with the coordinates of each rectangle predicted by a given alpha.
alphaRange = seq(from = -1, to = 1, by = .2)
gridSearch = array(NA, dim = c(length(alphaRange), 4)) # create an empty array to fill with the coordinates of each rectangle predicted by a given alpha.
i = 1
rect =  pedLearner(borders, observations, prior, alpha = alphaRange[i]) # generate all eligible rectangles (hypotheses)
orderedRect =  order(rect[, "posterior"], decreasing = TRUE) # order from highest to lowest probability
bestRect = as.numeric(rect[rect[,posterior == rect[orderedRect[1], posterior]], 1:4]) # take the most probable rectangle, keeping only the coordinate information (columns 1:4)
bestRect = as.numeric(rect[rect[,"posterior" == rect[orderedRect[1], "posterior"]], 1:4]) # take the most probable rectangle, keeping only the coordinate information (columns 1:4)
rect[,"posterior" == rect[orderedRect[1], "posterior"]
]
rect[rect[,"posterior"] == rect[orderedRect[1],"posterior"],]
View(rect)
bestRect = as.numeric(rect[rect[,"posterior"] == rect[orderedRect[1],"posterior"],1:4]) # take the most probable rectangle, keeping only the coordinate information (columns 1:4)
bestRect = as.numeric(rect[rect[,"posterior"] == rect[orderedRect[1],"posterior"],]) # take the most probable rectangle, keeping only the coordinate information (columns 1:4)
rect[rect[,"posterior"] == rect[orderedRect[1],"posterior"],]
as.numeric(rect[rect[,"posterior"] == rect[orderedRect[1],"posterior"],])
bestRect = rect[rect[,"posterior"] == rect[orderedRect[1],"posterior"],1:4] # take the most probable rectangle, keeping only the coordinate information (columns 1:4)
bestRect
#'
#' @param alphaRange vector of alpha values you want to search
#' @param borders entire range of possible rectangles
#' @param observations 3-columned labeled matrix of points provided by the teacher
#' @param prior prior probability of each rectangle
#'
#' @return 5 by length(alphaRange) array with rectangle coordinates and the alpha that generated those coordinates in each row.
#' @export
#'
#' @examples
alphaGridSearch = function(borders,
observations,
alphaRange = seq(from = -1, to = 1, by = .2),
prior = "uniform") {
#gridSearch = array(NA, dim = c(length(alphaRange), 4)) # create an empty array to fill with the coordinates of each rectangle predicted by a given alpha.
gridSearch = NULL
for (i in 1:length(alphaRange)) {
rect =  pedLearner(borders, observations, prior, alpha = alphaRange[i]) # generate all eligible rectangles (hypotheses)
orderedRect =  order(rect[, "posterior"], decreasing = TRUE) # order from highest to lowest probability
bestRect = rect[rect[,"posterior"] == rect[orderedRect[1],"posterior"],1:4] # take the most probable rectangle, keeping only the coordinate information (columns 1:4)
alpha = rep(alphaRange[i], length(gridSearch[,1]))
cbind(bestRect, alpha) # add a column so we know what alpha generated each rectangle
gridSearch = rbind(gridSearch,bestRect)
#gridSearch[i,] = bestRect # fill relevant row with the rectangle for that alpha
}
gridSearch = cbind(gridSearch, alphaRange)
colnames(gridSearch) = c("x1", "y1", "x2", "y2", "alpha") # name
return(gridSearch)
}
alphaGridSearch(borders, obs1[,1:3])
debugonce(alphaGridSearch)
alphaGridSearch(borders, obs1[,1:3])
View(bestRect)
#'
#' @param alphaRange vector of alpha values you want to search
#' @param borders entire range of possible rectangles
#' @param observations 3-columned labeled matrix of points provided by the teacher
#' @param prior prior probability of each rectangle
#'
#' @return 5 by length(alphaRange) array with rectangle coordinates and the alpha that generated those coordinates in each row.
#' @export
#'
#' @examples
alphaGridSearch = function(borders,
observations,
alphaRange = seq(from = -1, to = 1, by = .2),
prior = "uniform") {
#gridSearch = array(NA, dim = c(length(alphaRange), 4)) # create an empty array to fill with the coordinates of each rectangle predicted by a given alpha.
gridSearch = NULL
for (i in 1:length(alphaRange)) {
rect =  pedLearner(borders, observations, prior, alpha = alphaRange[i]) # generate all eligible rectangles (hypotheses)
orderedRect =  order(rect[, "posterior"], decreasing = TRUE) # order from highest to lowest probability
bestRect = rect[rect[,"posterior"] == rect[orderedRect[1],"posterior"],1:4] # take the most probable rectangle, keeping only the coordinate information (columns 1:4)
alpha = rep(alphaRange[i], length(bestRect[,1]))
cbind(bestRect, alpha) # add a column so we know what alpha generated each rectangle
gridSearch = rbind(gridSearch,bestRect)
#gridSearch[i,] = bestRect # fill relevant row with the rectangle for that alpha
}
gridSearch = cbind(gridSearch, alphaRange)
colnames(gridSearch) = c("x1", "y1", "x2", "y2", "alpha") # name
return(gridSearch)
}
alphaGridSearch(borders, obs1[,1:3])
debugonce(alphaGridSearch)
alphaGridSearch(borders, obs1[,1:3])
#'
#' @param alphaRange vector of alpha values you want to search
#' @param borders entire range of possible rectangles
#' @param observations 3-columned labeled matrix of points provided by the teacher
#' @param prior prior probability of each rectangle
#'
#' @return 5 by length(alphaRange) array with rectangle coordinates and the alpha that generated those coordinates in each row.
#' @export
#'
#' @examples
alphaGridSearch = function(borders,
observations,
alphaRange = seq(from = -1, to = 1, by = .2),
prior = "uniform") {
#gridSearch = array(NA, dim = c(length(alphaRange), 4)) # create an empty array to fill with the coordinates of each rectangle predicted by a given alpha.
gridSearch = NULL
for (i in 1:length(alphaRange)) {
rect =  pedLearner(borders, observations, prior, alpha = alphaRange[i]) # generate all eligible rectangles (hypotheses)
orderedRect =  order(rect[, "posterior"], decreasing = TRUE) # order from highest to lowest probability
bestRect = rect[rect[,"posterior"] == rect[orderedRect[1],"posterior"],1:4] # take the most probable rectangle, keeping only the coordinate information (columns 1:4)
alpha = rep(alphaRange[i], length(bestRect[,1]))
bestRect = cbind(bestRect, alpha) # add a column so we know what alpha generated each rectangle
gridSearch = rbind(gridSearch,bestRect)
#gridSearch[i,] = bestRect # fill relevant row with the rectangle for that alpha
}
gridSearch = cbind(gridSearch, alphaRange)
colnames(gridSearch) = c("x1", "y1", "x2", "y2", "alpha") # name
return(gridSearch)
}
alphaGridSearch(borders, obs1[,1:3])
#'
#' @param alphaRange vector of alpha values you want to search
#' @param borders entire range of possible rectangles
#' @param observations 3-columned labeled matrix of points provided by the teacher
#' @param prior prior probability of each rectangle
#'
#' @return 5 by length(alphaRange) array with rectangle coordinates and the alpha that generated those coordinates in each row.
#' @export
#'
#' @examples
alphaGridSearch = function(borders,
observations,
alphaRange = seq(from = -1, to = 1, by = .2),
prior = "uniform") {
#gridSearch = array(NA, dim = c(length(alphaRange), 4)) # create an empty array to fill with the coordinates of each rectangle predicted by a given alpha.
gridSearch = NULL
for (i in 1:length(alphaRange)) {
rect =  pedLearner(borders, observations, prior, alpha = alphaRange[i]) # generate all eligible rectangles (hypotheses)
orderedRect =  order(rect[, "posterior"], decreasing = TRUE) # order from highest to lowest probability
bestRect = rect[rect[,"posterior"] == rect[orderedRect[1],"posterior"],1:4] # take the most probable rectangle, keeping only the coordinate information (columns 1:4)
alpha = rep(alphaRange[i], length(bestRect[,1]))
bestRect = cbind(bestRect, alpha) # add a column so we know what alpha generated each rectangle
gridSearch = rbind(gridSearch,bestRect)
#gridSearch[i,] = bestRect # fill relevant row with the rectangle for that alpha
}
#gridSearch = cbind(gridSearch, alphaRange)
colnames(gridSearch) = c("x1", "y1", "x2", "y2", "alpha") # name
return(gridSearch)
}
alphaGridSearch(borders, obs1[,1:3])
obs1 = generateObs(nPos, nNeg, 1, trueRects)
alphaGridSearch(borders, obs1[,1:3])
sample(length(bestRect), 1)
sample(length(bestRect), 1)
sample(length(bestRect), 1)
sample(length(bestRect), 1)
sample(length(bestRect), 1)
bestRect
sample(1:length(bestRect), 1)
sample(1:length(bestRect), 1)
sample(1:length(bestRect), 1)
sample(1:length(bestRect), 1)
sample(1:length(bestRect), 1)
bestRect
bestRect), 1
sample(1:length(bestRect[,1]), 1)
sample(1:length(bestRect[,1]), 1)
sample(1:length(bestRect[,1]), 1)
sample(1:length(bestRect[,1]), 1)
sample(1:length(bestRect[,1]), 1)
sample(1:length(bestRect[,1]), 1)
sample(1:length(bestRect[,1]), 1)
parRect = bestRect[sample(1:length(bestRect[,1]), 1),] # randomly sample from those rectangles
parRect
simulatePar = function(obs,
borders,
prior = "uniform",
alpha = 1) {
rect = pedLearner(bordes, obs, prior = "uniform", alpha = alpha) # generate probability distribution of pedagogical learner for these observations
orderedRect =  order(rect[, "posterior"], decreasing = TRUE) # order from highest to lowest probability
bestRect = rect[rect[, "posterior"] == rect[orderedRect[1], "posterior"], 1:4] # filter rectangle(s) with highest probability
parRect = bestRect[sample(1:length(bestRect[, 1]), 1), ] # randomly sample from those rectangles
}
p1 = simulatePar(obs1, borders)
simulatePar = function(obs,
borders,
prior = "uniform",
alpha = 1) {
rect = pedLearner(borders, obs, prior = "uniform", alpha = alpha) # generate probability distribution of pedagogical learner for these observations
orderedRect =  order(rect[, "posterior"], decreasing = TRUE) # order from highest to lowest probability
bestRect = rect[rect[, "posterior"] == rect[orderedRect[1], "posterior"], 1:4] # filter rectangle(s) with highest probability
parRect = bestRect[sample(1:length(bestRect[, 1]), 1), ] # randomly sample from those rectangles
}
p1 = simulatePar(obs1, borders)
p1
alphas1 = alphaGridSearch(borders, obs1[,1:3])
View(alphas1)
overlap = rectOverlap(alphas1[,1:4], p1)
View(p1)
debugonce(overlap)
debugonce(rectOverlap)
overlap = rectOverlap(alphas1[,1:4], p1)
for (i in 1:length(alphas1[,1])) {
overlap[i] = rectOverlap(alphas1[i,1:4], p1)
}
for (i in 1:length(alphas1[,1])) {
overlap[i] = rectOverlap(c(alphas1[i,1:4]), p1)
}
debugonce(rectOverlap)
i = 1
rectOverlap(c(alphas1[i,1:4]), p1)
max(c(alphas1[1,1:4][1], alphas1[1,1:4][3])
max(c(alphas1[1,1:4][1], alphas1[1,1:4][3]))
max(c(alphas1[1,1:4][1], alphas1[1,1:4][3]))
alphas1[1,1:4][1]
alphas1[1,1:4]
tmp = alphas1[1,1:4]
tmp[1]
tmp[3]
tmp[3]
class(tmp[1])
tmp = c(alphas1[1,1:4])
class(tmp[1])
tmp = as.numeric(alphas1[1,1:4])
class(tmp[1])
overlap[i] = rectOverlap(as.numeric(alphas1[i,1:4]), p1)
for (i in 1:length(alphas1[,1])) {
overlap[i] = rectOverlap(as.numeric(alphas1[i,1:4]), p1)
}
class(p1)
overlap[i] = rectOverlap(as.numeric(alphas1[i,1:4]), as.numeric(p1))
as.numeric(p1)
for (i in 1:length(alphas1[,1])) {
overlap[i] = rectOverlap(as.numeric(alphas1[i,1:4]), as.numeric(p1))
}
overlap = NULL
for (i in 1:length(alphas1[,1])) {
overlap[i] = rectOverlap(as.numeric(alphas1[i,1:4]), as.numeric(p1))
}
overlap[i]
length(alphas1[,1])
for (i in 1:length(alphas1[,1])) {
overlap[i] = rectOverlap(as.numeric(alphas1[i,1:4]), as.numeric(p1))
}
overlap[i]
#' Find the area of overlap between two rectangles
#'
#' @param rect1 coordinates of first rectangle, e.g., c(<x1>, <y1>, <x2>, <y2>)
#' @param rect2 coordinates of second rectangle
#'
#' @return area of overlap between the two rectangles
#'
#' @examples rectOverlap(rect1 = c(2,2,6,6), rect2 = c(4,4,8,8))
rectOverlap = function(rect1, rect2) {
rect1 = as.numeric(rect1)
rect2 = as.numeric(rect2)
# figure out which x and y values are the maximum and minimum values of each rectangle
x1Max = max(c(rect1[1], rect1[3]))
x1Min = min(c(rect1[1], rect1[3]))
y1Max = max(c(rect1[2], rect1[4]))
y1Min = min(c(rect1[2], rect1[4]))
x2Max = max(c(rect2[1], rect2[3]))
x2Min = min(c(rect2[1], rect2[3]))
y2Max = max(c(rect2[2], rect2[4]))
y2Min = min(c(rect2[2], rect2[4]))
# equation for calculating the area of the overlap
dx = min(x1Max, x2Max) - max(x1Min, x2Min)
dy = min(y1Max, y2Max) - max(y1Min, y2Min)
if (dx >= 0 & dy >= 0) {
size = dx * dy
} else {
size = 0
}
return(size)
}
overlap = NULL
for (i in 1:length(alphas1[,1])) {
overlap[i] = rectOverlap(alphas1[i,1:4], p1)
}
max(overlap)
overlap
alphas1
rectOverlap(c(0,4,10,9), p1)
plot(x = c(1,10), y = c(10,10))
plot(x = c(1,1), y = c(10,10))
plot(x = c(1,10), y = c(1,10))
rect(0,4,10,9)
findSize(p1)
p1
rect(5,8,6,9)
test = findSize(alphas1[1:4])
View(test)
#' Find the area of overlap between two rectangles
#'
#' @param rect1 coordinates of first rectangle, e.g., c(<x1>, <y1>, <x2>, <y2>)
#' @param rect2 coordinates of second rectangle
#'
#' @return area of overlap between the two rectangles
#'
#' @examples rectOverlap(rect1 = c(2,2,6,6), rect2 = c(4,4,8,8))
rectOverlap = function(rect1, rect2) {
rect1 = as.numeric(rect1)
rect2 = as.numeric(rect2)
# figure out which x and y values are the maximum and minimum values of each rectangle
x1Max = max(c(rect1[1], rect1[3]))
x1Min = min(c(rect1[1], rect1[3]))
y1Max = max(c(rect1[2], rect1[4]))
y1Min = min(c(rect1[2], rect1[4]))
x2Max = max(c(rect2[1], rect2[3]))
x2Min = min(c(rect2[1], rect2[3]))
y2Max = max(c(rect2[2], rect2[4]))
y2Min = min(c(rect2[2], rect2[4]))
# equation for calculating the area of the overlap
dx = min(x1Max, x2Max) - max(x1Min, x2Min)
dy = min(y1Max, y2Max) - max(y1Min, y2Min)
if (dx >= 0 & dy >= 0) {
size = dx * dy
prop = size/max(findSize(rect1), findSize(rect2)) # prop = proportion of overlap
} else {
prop = 0
}
return(prop)
}
for (i in 1:length(alphas1[,1])) {
overlap[i] = rectOverlap(alphas1[i,1:4], p1)
}
max(overlap)
overlap
overlap[overlap == 1]
alphas1[overlap == 1, ]
p1 = simulatePar(obs1, borders, alpha = -1)
overlap = NULL
for (i in 1:length(alphas1[,1])) {
overlap[i] = rectOverlap(alphas1[i,1:4], p1)
}
alphas1[overlap == 1, ]
p1 = simulatePar(obs1, borders, alpha = 1)
overlap = NULL
for (i in 1:length(alphas1[,1])) {
overlap[i] = rectOverlap(alphas1[i,1:4], p1)
}
alphas1[overlap == 1, ]
p1 = simulatePar(obs1, borders, alpha = 10)
overlap = NULL
for (i in 1:length(alphas1[,1])) {
overlap[i] = rectOverlap(alphas1[i,1:4], p1)
}
alphas1[overlap == 1, ]
alphas1[,alphas1[,"alpha"] == 0]
head(alphas1)
alphas1[,alphas1[,"alpha"] == 0]
alphas1[alphas1[,"alpha"] == 0,]
pedLearner(borders, observations, prior, alpha = alphaRange[i])
pedLearner(borders, obs1, prior, alpha = alphaRange[i])
alphas1[alphas1[,"alpha"] == 0,]
alphas1
#'
#' @param alphaRange vector of alpha values you want to search
#' @param borders entire range of possible rectangles
#' @param observations 3-columned labeled matrix of points provided by the teacher
#' @param prior prior probability of each rectangle
#'
#' @return 5 by length(alphaRange) array with rectangle coordinates and the alpha that generated those coordinates in each row.
#' @export
#'
#' @examples
alphaGridSearch = function(borders,
observations,
alphaRange = seq(from = -1, to = 1, by = .2),
prior = "uniform") {
gridSearch = NULL
for (i in 1:length(alphaRange)) {
rect =  pedLearner(borders, observations, prior, alpha = alphaRange[i]) # generate all eligible rectangles (hypotheses)
orderedRect =  order(rect[, "posterior"], decreasing = TRUE) # order from highest to lowest probability
bestRect = rect[rect[,"posterior"] == rect[orderedRect[1],"posterior"],1:4] # take the most probable rectangle, keeping only the coordinate information (columns 1:4)
alpha = rep(alphaRange[i], length(bestRect[,1]))
prob = rep(1/length(bestRect[,1]), length(bestRect[,1]))
bestRect = cbind(bestRect, alpha, prob) # add a column so we know what alpha generated each rectangle
gridSearch = rbind(gridSearch,bestRect)
}
colnames(gridSearch) = c("x1", "y1", "x2", "y2", "alpha") # name
return(gridSearch)
}
alphas1 = alphaGridSearch(borders, obs1[,1:3])
alphas1
#'
#' @param alphaRange vector of alpha values you want to search
#' @param borders entire range of possible rectangles
#' @param observations 3-columned labeled matrix of points provided by the teacher
#' @param prior prior probability of each rectangle
#'
#' @return 5 by length(alphaRange) array with rectangle coordinates and the alpha that generated those coordinates in each row.
#' @export
#'
#' @examples
alphaGridSearch = function(borders,
observations,
alphaRange = seq(from = -1, to = 1, by = .2),
prior = "uniform") {
gridSearch = NULL
for (i in 1:length(alphaRange)) {
rect =  pedLearner(borders, observations, prior, alpha = alphaRange[i]) # generate all eligible rectangles (hypotheses)
orderedRect =  order(rect[, "posterior"], decreasing = TRUE) # order from highest to lowest probability
bestRect = rect[rect[,"posterior"] == rect[orderedRect[1],"posterior"],1:4] # take the most probable rectangle, keeping only the coordinate information (columns 1:4)
alpha = rep(alphaRange[i], length(bestRect[,1]))
prob = rep(1/length(bestRect[,1]), length(bestRect[,1]))
bestRect = cbind(bestRect, alpha, prob) # add a column so we know what alpha generated each rectangle
gridSearch = rbind(gridSearch,bestRect)
}
colnames(gridSearch) = c("x1", "y1", "x2", "y2", "alpha", "prob") # name
return(gridSearch)
}
alphas1 = alphaGridSearch(borders, obs1[,1:3])
alphas1
p1 = simulatePar(obs1, borders, alpha = 10)
overlap = NULL
for (i in 1:length(alphas1[,1])) {
overlap[i] = rectOverlap(alphas1[i,1:4], p1)
}
alphas1[overlap == 1, ]
p1 = simulatePar(obs1, borders, alpha = 0)
p1 = simulatePar(obs1, borders, alpha = 0)
overlap = NULL
for (i in 1:length(alphas1[,1])) {
overlap[i] = rectOverlap(alphas1[i,1:4], p1)
}
alphas1[overlap == 1, ]
