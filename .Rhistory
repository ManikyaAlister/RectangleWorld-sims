test = pedTeacher(cat1,range,nPoints = 3)
View(learner)
View(learnerPrior)
pedTeacher = function(trueRectangle, range, nPoints){
# calculate all eligible possible rectangles within range
borders = makeBorders(range)
# set up all possible points
allPoints = expand.grid(range,range)
# label points as either positive or negative evidence
f = function(p) isInRectangle(r = trueRectangle, p = p) # alter isInRectangle function to be appropriate for apply() (include true rectangle)
positiveEvidence = apply(allPoints,1,f) # tells us if a point is in the rectangle or not
category = rep(NA,length(allPoints)) # empty column to fill with labels
observations = cbind(allPoints,category) # join into 1 matrix
for (i in 1:length(positiveEvidence)){
if (positiveEvidence[i] == TRUE){
observations[i,"category"] = "positive"
} else {
observations[i,"category"] = "negative"
}
}
# See which points maximize the pedagogical learner's posterior probability that the true rectangle is the best rectangle relative to the other rectangle
# set up array to fill with priors
learnerPrior = array(NA, dim = c(length(borders[,1]),nPoints))
# Set the learner's initial prior
learnerPrior[,1] = rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))) # uniform prior to start
# empty vector to fill with the points that th teacher chooses
point = c()
# loop through each point that the teacher is providing
for (j in 1:nPoints){
# set up an empty data frame to fill with the probability of the true rectangle given each point
probTrueRect = c()
# Calculate the learner's posterior for each hypothesis for each point:
for (i in 1:length(observations[,1])){
observation = as.vector(as.matrix(observations[i,])) # needs to be a vector for pedLearner, but as.vector() wouldn't work unless it was first converted to a matrix. Not sure why.
names(observation) = c("Var1","Var2","category") # needs to be named vector for pedLearner to work
learner = pedLearner(borders,observation, prior = learnerPrior[,j])
pointProb = learner[learner[,1] == trueRectangle[1] & learner[,2] == trueRectangle[2] & learner[,3] == trueRectangle[3] & learner[,4] == trueRectangle[4],"posterior"] # extract just the probability of the true rectangle for each
probTrueRect[i] = pointProb
}
# choose the point with the largest probability
maxProb = which.max(probTrueRect) # <-- seems like it's giving the same probability for every positive point and every negative point.
point[j] = allPoints[maxProb,]
learnerPrior[,j+1] = learner[,"posterior"] # the learner's prior about the rectangles for the next point is their posterior from the last point
observations = observations[-observations[maxProb,],]
}
return(point)
}
test = pedTeacher(cat1,range,nPoints = 3)
debugonce(pedTeacher)
test = pedTeacher(cat1,range,nPoints = 3)
View(learner)
point
allPoints[maxProb,]
pedTeacher = function(trueRectangle, range, nPoints){
# calculate all eligible possible rectangles within range
borders = makeBorders(range)
# set up all possible points
allPoints = expand.grid(range,range)
# label points as either positive or negative evidence
f = function(p) isInRectangle(r = trueRectangle, p = p) # alter isInRectangle function to be appropriate for apply() (include true rectangle)
positiveEvidence = apply(allPoints,1,f) # tells us if a point is in the rectangle or not
category = rep(NA,length(allPoints)) # empty column to fill with labels
observations = cbind(allPoints,category) # join into 1 matrix
for (i in 1:length(positiveEvidence)){
if (positiveEvidence[i] == TRUE){
observations[i,"category"] = "positive"
} else {
observations[i,"category"] = "negative"
}
}
# See which points maximize the pedagogical learner's posterior probability that the true rectangle is the best rectangle relative to the other rectangle
# set up array to fill with priors
learnerPrior = array(NA, dim = c(length(borders[,1]),nPoints))
# Set the learner's initial prior
learnerPrior[,1] = rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))) # uniform prior to start
# empty vector to fill with the points that th teacher chooses
point = array(NA,c(nPoints,2))
# loop through each point that the teacher is providing
for (j in 1:nPoints){
# set up an empty data frame to fill with the probability of the true rectangle given each point
probTrueRect = c()
# Calculate the learner's posterior for each hypothesis for each point:
for (i in 1:length(observations[,1])){
observation = as.vector(as.matrix(observations[i,])) # needs to be a vector for pedLearner, but as.vector() wouldn't work unless it was first converted to a matrix. Not sure why.
names(observation) = c("Var1","Var2","category") # needs to be named vector for pedLearner to work
learner = pedLearner(borders,observation, prior = learnerPrior[,j])
pointProb = learner[learner[,1] == trueRectangle[1] & learner[,2] == trueRectangle[2] & learner[,3] == trueRectangle[3] & learner[,4] == trueRectangle[4],"posterior"] # extract just the probability of the true rectangle for each
probTrueRect[i] = pointProb
}
# choose the point with the largest probability
maxProb = which.max(probTrueRect) # <-- seems like it's giving the same probability for every positive point and every negative point.
point[j,] = allPoints[maxProb,]
learnerPrior[,j+1] = learner[,"posterior"] # the learner's prior about the rectangles for the next point is their posterior from the last point
observations = observations[-observations[maxProb,],]
}
return(point)
}
test = pedTeacher(cat1,range,nPoints = 3)
debugonce(pedTeacher)
test = pedTeacher(cat1,range,nPoints = 3)
i = 1
j = 1
# set up array to fill with priors
learnerPrior = array(NA, dim = c(length(borders[,1]),nPoints))
# Set the learner's initial prior
learnerPrior[,1] = rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))) # uniform prior to start
# empty vector to fill with the points that th teacher chooses
point = array(NA,c(nPoints,2))
# set up an empty data frame to fill with the probability of the true rectangle given each point
probTrueRect = c()
# choose the point with the largest probability
maxProb = which.max(probTrueRect) # <-- seems like it's giving the same probability for every positive point and every negative point.
observation = as.vector(as.matrix(observations[i,])) # needs to be a vector for pedLearner, but as.vector() wouldn't work unless it was first converted to a matrix. Not sure why.
names(observation) = c("Var1","Var2","category") # needs to be named vector for pedLearner to work
learner = pedLearner(borders,observation, prior = learnerPrior[,j])
pointProb = learner[learner[,1] == trueRectangle[1] & learner[,2] == trueRectangle[2] & learner[,3] == trueRectangle[3] & learner[,4] == trueRectangle[4],"posterior"] # extract just the probability of the true rectangle for each
probTrueRect[i] = pointProb
# choose the point with the largest probability
maxProb = which.max(probTrueRect) # <-- seems like it's giving the same probability for every positive point and every negative point.
point[j,] = allPoints[maxProb,]
allPoints[maxProb,]
# empty vector to fill with the points that th teacher chooses
point = array(NA,c(nPoints,2))
View(point)
point[j,] = allPoints[maxProb,]
View(point)
# empty vector to fill with the points that th teacher chooses
point = array(NA,c(nPoints,2))
point[j,] = allPoints[maxProb,]
# empty vector to fill with the points that th teacher chooses
point = array(NA,c(nPoints,2))
point[j,]
allPoints[maxProb,]
class(allPoints[maxProb,])
point[j,] = as.vector(allPoints[maxProb,])
# empty vector to fill with the points that th teacher chooses
point = array(NA,c(nPoints,2))
point[j,] = as.matrix(allPoints[maxProb,])
View(point)
pedTeacher = function(trueRectangle, range, nPoints){
# calculate all eligible possible rectangles within range
borders = makeBorders(range)
# set up all possible points
allPoints = expand.grid(range,range)
# label points as either positive or negative evidence
f = function(p) isInRectangle(r = trueRectangle, p = p) # alter isInRectangle function to be appropriate for apply() (include true rectangle)
positiveEvidence = apply(allPoints,1,f) # tells us if a point is in the rectangle or not
category = rep(NA,length(allPoints)) # empty column to fill with labels
observations = cbind(allPoints,category) # join into 1 matrix
for (i in 1:length(positiveEvidence)){
if (positiveEvidence[i] == TRUE){
observations[i,"category"] = "positive"
} else {
observations[i,"category"] = "negative"
}
}
# See which points maximize the pedagogical learner's posterior probability that the true rectangle is the best rectangle relative to the other rectangle
# set up array to fill with priors
learnerPrior = array(NA, dim = c(length(borders[,1]),nPoints))
# Set the learner's initial prior
learnerPrior[,1] = rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))) # uniform prior to start
# empty vector to fill with the points that th teacher chooses
point = array(NA,c(nPoints,2))
# loop through each point that the teacher is providing
for (j in 1:nPoints){
# set up an empty data frame to fill with the probability of the true rectangle given each point
probTrueRect = c()
# Calculate the learner's posterior for each hypothesis for each point:
for (i in 1:length(observations[,1])){
observation = as.vector(as.matrix(observations[i,])) # needs to be a vector for pedLearner, but as.vector() wouldn't work unless it was first converted to a matrix. Not sure why.
names(observation) = c("Var1","Var2","category") # needs to be named vector for pedLearner to work
learner = pedLearner(borders,observation, prior = learnerPrior[,j])
pointProb = learner[learner[,1] == trueRectangle[1] & learner[,2] == trueRectangle[2] & learner[,3] == trueRectangle[3] & learner[,4] == trueRectangle[4],"posterior"] # extract just the probability of the true rectangle for each
probTrueRect[i] = pointProb
}
# choose the point with the largest probability
maxProb = which.max(probTrueRect) # <-- seems like it's giving the same probability for every positive point and every negative point.
point[j,] = as.matrix(allPoints[maxProb,])
learnerPrior[,j+1] = learner[,"posterior"] # the learner's prior about the rectangles for the next point is their posterior from the last point
observations = observations[-observations[maxProb,],]
}
return(point)
}
test = pedTeacher(cat1,range,nPoints = 3)
i = 1
j = 1
# empty vector to fill with the points that th teacher chooses
point = array(NA,c(nPoints,2))
observation = as.vector(as.matrix(observations[i,])) # needs to be a vector for pedLearner, but as.vector() wouldn't work unless it was first converted to a matrix. Not sure why.
names(observation) = c("Var1","Var2","category") # needs to be named vector for pedLearner to work
learner = pedLearner(borders,observation, prior = learnerPrior[,j])
pointProb = learner[learner[,1] == trueRectangle[1] & learner[,2] == trueRectangle[2] & learner[,3] == trueRectangle[3] & learner[,4] == trueRectangle[4],"posterior"] # extract just the probability of the true rectangle for each
probTrueRect[i] = pointProb
# choose the point with the largest probability
maxProb = which.max(probTrueRect) # <-- seems like it's giving the same probability for every positive point and every negative point.
point[j,] = as.matrix(allPoints[maxProb,])
learnerPrior[,j+1] = learner[,"posterior"] # the learner's prior about the rectangles for the next point is their posterior from the last point
observations = observations[-observations[maxProb,],]
observations = observations[-maxProb,]
test = pedTeacher(cat1,range,nPoints = 3)
pedTeacher = function(trueRectangle, range, nPoints){
# calculate all eligible possible rectangles within range
borders = makeBorders(range)
# set up all possible points
allPoints = expand.grid(range,range)
# label points as either positive or negative evidence
f = function(p) isInRectangle(r = trueRectangle, p = p) # alter isInRectangle function to be appropriate for apply() (include true rectangle)
positiveEvidence = apply(allPoints,1,f) # tells us if a point is in the rectangle or not
category = rep(NA,length(allPoints)) # empty column to fill with labels
observations = cbind(allPoints,category) # join into 1 matrix
for (i in 1:length(positiveEvidence)){
if (positiveEvidence[i] == TRUE){
observations[i,"category"] = "positive"
} else {
observations[i,"category"] = "negative"
}
}
# See which points maximize the pedagogical learner's posterior probability that the true rectangle is the best rectangle relative to the other rectangle
# set up array to fill with priors
learnerPrior = array(NA, dim = c(length(borders[,1]),nPoints))
# Set the learner's initial prior
learnerPrior[,1] = rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))) # uniform prior to start
# empty vector to fill with the points that th teacher chooses
point = array(NA,c(nPoints,2))
# loop through each point that the teacher is providing
for (j in 1:nPoints){
# set up an empty data frame to fill with the probability of the true rectangle given each point
probTrueRect = c()
# Calculate the learner's posterior for each hypothesis for each point:
for (i in 1:length(observations[,1])){
observation = as.vector(as.matrix(observations[i,])) # needs to be a vector for pedLearner, but as.vector() wouldn't work unless it was first converted to a matrix. Not sure why.
names(observation) = c("Var1","Var2","category") # needs to be named vector for pedLearner to work
learner = pedLearner(borders,observation, prior = learnerPrior[,j])
pointProb = learner[learner[,1] == trueRectangle[1] & learner[,2] == trueRectangle[2] & learner[,3] == trueRectangle[3] & learner[,4] == trueRectangle[4],"posterior"] # extract just the probability of the true rectangle for each
probTrueRect[i] = pointProb
}
# choose the point with the largest probability
maxProb = which.max(probTrueRect) # <-- seems like it's giving the same probability for every positive point and every negative point.
point[j,] = as.matrix(allPoints[maxProb,])
learnerPrior[,j+1] = learner[,"posterior"] # the learner's prior about the rectangles for the next point is their posterior from the last point
observations = observations[-maxProb,]
}
return(point)
}
test = pedTeacher(cat1,range,nPoints = 3)
pedTeacher = function(trueRectangle, range, nPoints){
# calculate all eligible possible rectangles within range
borders = makeBorders(range)
# set up all possible points
allPoints = expand.grid(range,range)
# label points as either positive or negative evidence
f = function(p) isInRectangle(r = trueRectangle, p = p) # alter isInRectangle function to be appropriate for apply() (include true rectangle)
positiveEvidence = apply(allPoints,1,f) # tells us if a point is in the rectangle or not
category = rep(NA,length(allPoints)) # empty column to fill with labels
observations = cbind(allPoints,category) # join into 1 matrix
for (i in 1:length(positiveEvidence)){
if (positiveEvidence[i] == TRUE){
observations[i,"category"] = "positive"
} else {
observations[i,"category"] = "negative"
}
}
# See which points maximize the pedagogical learner's posterior probability that the true rectangle is the best rectangle relative to the other rectangle
# set up array to fill with priors
learnerPrior = array(NA, dim = c(length(borders[,1]),nPoints))
# Set the learner's initial prior
learnerPrior[,1] = rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))) # uniform prior to start
# empty vector to fill with the points that th teacher chooses
point = array(NA,c(nPoints,2))
# loop through each point that the teacher is providing
for (j in 1:nPoints+1){ # + 1 because there needs to be space for the podsterior of the 3rd point + 1
# set up an empty data frame to fill with the probability of the true rectangle given each point
probTrueRect = c()
# Calculate the learner's posterior for each hypothesis for each point:
for (i in 1:length(observations[,1])){
observation = as.vector(as.matrix(observations[i,])) # needs to be a vector for pedLearner, but as.vector() wouldn't work unless it was first converted to a matrix. Not sure why.
names(observation) = c("Var1","Var2","category") # needs to be named vector for pedLearner to work
learner = pedLearner(borders,observation, prior = learnerPrior[,j])
pointProb = learner[learner[,1] == trueRectangle[1] & learner[,2] == trueRectangle[2] & learner[,3] == trueRectangle[3] & learner[,4] == trueRectangle[4],"posterior"] # extract just the probability of the true rectangle for each
probTrueRect[i] = pointProb
}
# choose the point with the largest probability
maxProb = which.max(probTrueRect) # <-- seems like it's giving the same probability for every positive point and every negative point.
point[j,] = as.matrix(allPoints[maxProb,])
learnerPrior[,j+1] = learner[,"posterior"] # the learner's prior about the rectangles for the next point is their posterior from the last point
observations = observations[-maxProb,]
}
return(point)
}
test = pedTeacher(cat1,range,nPoints = 3)
i
j
# set up array to fill with priors
learnerPrior = array(NA, dim = c(length(borders[,1]),nPoints))
# Set the learner's initial prior
learnerPrior[,1] = rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))) # uniform prior to start
# empty vector to fill with the points that th teacher chooses
point = array(NA,c(nPoints,2))
# set up an empty data frame to fill with the probability of the true rectangle given each point
probTrueRect = c()
observation = as.vector(as.matrix(observations[i,])) # needs to be a vector for pedLearner, but as.vector() wouldn't work unless it was first converted to a matrix. Not sure why.
names(observation) = c("Var1","Var2","category") # needs to be named vector for pedLearner to work
learner = pedLearner(borders,observation, prior = learnerPrior[,j])
pointProb = learner[learner[,1] == trueRectangle[1] & learner[,2] == trueRectangle[2] & learner[,3] == trueRectangle[3] & learner[,4] == trueRectangle[4],"posterior"] # extract just the probability of the true rectangle for each
probTrueRect[i] = pointProb
# choose the point with the largest probability
maxProb = which.max(probTrueRect) # <-- seems like it's giving the same probability for every positive point and every negative point.
point[j,] = as.matrix(allPoints[maxProb,])
learnerPrior[,j+1] = learner[,"posterior"] # the learner's prior about the rectangles for the next point is their posterior from the last point
observations = observations[-maxProb,]
j = 2
# set up an empty data frame to fill with the probability of the true rectangle given each point
probTrueRect = c()
observation = as.vector(as.matrix(observations[i,])) # needs to be a vector for pedLearner, but as.vector() wouldn't work unless it was first converted to a matrix. Not sure why.
names(observation) = c("Var1","Var2","category") # needs to be named vector for pedLearner to work
learner = pedLearner(borders,observation, prior = learnerPrior[,j])
pointProb = learner[learner[,1] == trueRectangle[1] & learner[,2] == trueRectangle[2] & learner[,3] == trueRectangle[3] & learner[,4] == trueRectangle[4],"posterior"] # extract just the probability of the true rectangle for each
probTrueRect[i] = pointProb
# choose the point with the largest probability
maxProb = which.max(probTrueRect) # <-- seems like it's giving the same probability for every positive point and every negative point.
point[j,] = as.matrix(allPoints[maxProb,])
learnerPrior[,j+1] = learner[,"posterior"] # the learner's prior about the rectangles for the next point is their posterior from the last point
observations = observations[-maxProb,]
View(learnerPrior)
j = 3
# set up an empty data frame to fill with the probability of the true rectangle given each point
probTrueRect = c()
observation = as.vector(as.matrix(observations[i,])) # needs to be a vector for pedLearner, but as.vector() wouldn't work unless it was first converted to a matrix. Not sure why.
names(observation) = c("Var1","Var2","category") # needs to be named vector for pedLearner to work
learner = pedLearner(borders,observation, prior = learnerPrior[,j])
pointProb = learner[learner[,1] == trueRectangle[1] & learner[,2] == trueRectangle[2] & learner[,3] == trueRectangle[3] & learner[,4] == trueRectangle[4],"posterior"] # extract just the probability of the true rectangle for each
probTrueRect[i] = pointProb
# choose the point with the largest probability
maxProb = which.max(probTrueRect) # <-- seems like it's giving the same probability for every positive point and every negative point.
point[j,] = as.matrix(allPoints[maxProb,])
observations = observations[-maxProb,]
View(point)
observations = observations[-maxProb,]
View(observations)
debugonce(pedTeacher)
test = pedTeacher(cat1,range,nPoints = 3)
debugonce(pedTeacher)
test = pedTeacher(cat1,range,nPoints = 3)
View(learner)
View(learner)
View(learnerPrior)
j
pedTeacher = function(trueRectangle, range, nPoints){
# calculate all eligible possible rectangles within range
borders = makeBorders(range)
# set up all possible points
allPoints = expand.grid(range,range)
# label points as either positive or negative evidence
f = function(p) isInRectangle(r = trueRectangle, p = p) # alter isInRectangle function to be appropriate for apply() (include true rectangle)
positiveEvidence = apply(allPoints,1,f) # tells us if a point is in the rectangle or not
category = rep(NA,length(allPoints)) # empty column to fill with labels
observations = cbind(allPoints,category) # join into 1 matrix
for (i in 1:length(positiveEvidence)){
if (positiveEvidence[i] == TRUE){
observations[i,"category"] = "positive"
} else {
observations[i,"category"] = "negative"
}
}
# See which points maximize the pedagogical learner's posterior probability that the true rectangle is the best rectangle relative to the other rectangle
# set up array to fill with priors
learnerPrior = array(NA, dim = c(length(borders[,1]),nPoints))
# Set the learner's initial prior
learnerPrior[,1] = rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))) # uniform prior to start
# empty vector to fill with the points that th teacher chooses
point = array(NA,c(nPoints+1,2)) # nPoints "+ 1" because there needs to be space for the podsterior of the 3rd point + 1
# loop through each point that the teacher is providing
for (j in 1:nPoints){
# set up an empty data frame to fill with the probability of the true rectangle given each point
probTrueRect = c()
# Calculate the learner's posterior for each hypothesis for each point:
for (i in 1:length(observations[,1])){
observation = as.vector(as.matrix(observations[i,])) # needs to be a vector for pedLearner, but as.vector() wouldn't work unless it was first converted to a matrix. Not sure why.
names(observation) = c("Var1","Var2","category") # needs to be named vector for pedLearner to work
learner = pedLearner(borders,observation, prior = learnerPrior[,j])
pointProb = learner[learner[,1] == trueRectangle[1] & learner[,2] == trueRectangle[2] & learner[,3] == trueRectangle[3] & learner[,4] == trueRectangle[4],"posterior"] # extract just the probability of the true rectangle for each
probTrueRect[i] = pointProb
}
# choose the point with the largest probability
maxProb = which.max(probTrueRect) # <-- seems like it's giving the same probability for every positive point and every negative point.
point[j,] = as.matrix(allPoints[maxProb,])
learnerPrior[,j+1] = learner[,"posterior"] # the learner's prior about the rectangles for the next point is their posterior from the last point
observations = observations[-maxProb,]
}
return(point)
}
test = pedTeacher(cat1,range,nPoints = 3)
# Set the learner's initial prior
learnerPrior[,1] = rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))) # uniform prior to start
# empty vector to fill with the points that th teacher chooses
point = array(NA,c(nPoints+1,2)) # nPoints "+ 1" because there needs to be space for the podsterior of the 3rd point + 1
pedTeacher = function(trueRectangle, range, nPoints){
# calculate all eligible possible rectangles within range
borders = makeBorders(range)
# set up all possible points
allPoints = expand.grid(range,range)
# label points as either positive or negative evidence
f = function(p) isInRectangle(r = trueRectangle, p = p) # alter isInRectangle function to be appropriate for apply() (include true rectangle)
positiveEvidence = apply(allPoints,1,f) # tells us if a point is in the rectangle or not
category = rep(NA,length(allPoints)) # empty column to fill with labels
observations = cbind(allPoints,category) # join into 1 matrix
for (i in 1:length(positiveEvidence)){
if (positiveEvidence[i] == TRUE){
observations[i,"category"] = "positive"
} else {
observations[i,"category"] = "negative"
}
}
# See which points maximize the pedagogical learner's posterior probability that the true rectangle is the best rectangle relative to the other rectangle
# set up array to fill with priors
learnerPrior = array(NA, dim = c(length(borders[,1]),nPoints+1)) # nPoints "+ 1" because there needs to be space for the podsterior of the 3rd point + 1
# Set the learner's initial prior
learnerPrior[,1] = rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))) # uniform prior to start
# empty vector to fill with the points that th teacher chooses
point = array(NA,c(nPoints,2))
# loop through each point that the teacher is providing
for (j in 1:nPoints){
# set up an empty data frame to fill with the probability of the true rectangle given each point
probTrueRect = c()
# Calculate the learner's posterior for each hypothesis for each point:
for (i in 1:length(observations[,1])){
observation = as.vector(as.matrix(observations[i,])) # needs to be a vector for pedLearner, but as.vector() wouldn't work unless it was first converted to a matrix. Not sure why.
names(observation) = c("Var1","Var2","category") # needs to be named vector for pedLearner to work
learner = pedLearner(borders,observation, prior = learnerPrior[,j])
pointProb = learner[learner[,1] == trueRectangle[1] & learner[,2] == trueRectangle[2] & learner[,3] == trueRectangle[3] & learner[,4] == trueRectangle[4],"posterior"] # extract just the probability of the true rectangle for each
probTrueRect[i] = pointProb
}
# choose the point with the largest probability
maxProb = which.max(probTrueRect) # <-- seems like it's giving the same probability for every positive point and every negative point.
point[j,] = as.matrix(allPoints[maxProb,])
learnerPrior[,j+1] = learner[,"posterior"] # the learner's prior about the rectangles for the next point is their posterior from the last point
observations = observations[-maxProb,]
}
return(point)
}
test = pedTeacher(cat1,range,nPoints = 3)
View(test)
# set up array to fill with priors
learnerPrior = array(NA, dim = c(length(borders[,1]),nPoints+1)) # nPoints "+ 1" because there needs to be space for the podsterior of the 3rd point + 1
# Set the learner's initial prior
learnerPrior[,1] = rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))) # uniform prior to start
# empty vector to fill with the points that th teacher chooses
point = array(NA,c(nPoints,2))
# set up an empty data frame to fill with the probability of the true rectangle given each point
probTrueRect = c()
i
j
j = 1
observation = as.vector(as.matrix(observations[i,])) # needs to be a vector for pedLearner, but as.vector() wouldn't work unless it was first converted to a matrix. Not sure why.
names(observation) = c("Var1","Var2","category") # needs to be named vector for pedLearner to work
learner = pedLearner(borders,observation, prior = learnerPrior[,j])
pointProb = learner[learner[,1] == trueRectangle[1] & learner[,2] == trueRectangle[2] & learner[,3] == trueRectangle[3] & learner[,4] == trueRectangle[4],"posterior"] # extract just the probability of the true rectangle for each
probTrueRect[i] = pointProb
# choose the point with the largest probability
maxProb = which.max(probTrueRect) # <-- seems like it's giving the same probability for every positive point and every negative point.
point[j,] = as.matrix(allPoints[maxProb,])
learnerPrior[,j+1] = learner[,"posterior"] # the learner's prior about the rectangles for the next point is their posterior from the last point
View(observations)
pedTeacher = function(trueRectangle, range, nPoints){
# calculate all eligible possible rectangles within range
borders = makeBorders(range)
# set up all possible points
allPoints = expand.grid(range,range)
# label points as either positive or negative evidence
f = function(p) isInRectangle(r = trueRectangle, p = p) # alter isInRectangle function to be appropriate for apply() (include true rectangle)
positiveEvidence = apply(allPoints,1,f) # tells us if a point is in the rectangle or not
category = rep(NA,length(allPoints)) # empty column to fill with labels
observations = cbind(allPoints,category) # join into 1 matrix
for (i in 1:length(positiveEvidence)){
if (positiveEvidence[i] == TRUE){
observations[i,"category"] = "positive"
} else {
observations[i,"category"] = "negative"
}
}
# See which points maximize the pedagogical learner's posterior probability that the true rectangle is the best rectangle relative to the other rectangle
# set up array to fill with priors
learnerPrior = array(NA, dim = c(length(borders[,1]),nPoints+1)) # nPoints "+ 1" because there needs to be space for the podsterior of the 3rd point + 1
# Set the learner's initial prior
learnerPrior[,1] = rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))) # uniform prior to start
# empty vector to fill with the points that th teacher chooses
point = array(NA,c(nPoints,2))
# loop through each point that the teacher is providing
for (j in 1:nPoints){
# set up an empty data frame to fill with the probability of the true rectangle given each point
probTrueRect = c()
# Calculate the learner's posterior for each hypothesis for each point:
for (i in 1:length(observations[,1])){
observation = as.vector(as.matrix(observations[i,])) # needs to be a vector for pedLearner, but as.vector() wouldn't work unless it was first converted to a matrix. Not sure why.
names(observation) = c("Var1","Var2","category") # needs to be named vector for pedLearner to work
learner = pedLearner(borders,observation, prior = learnerPrior[,j])
pointProb = learner[learner[,1] == trueRectangle[1] & learner[,2] == trueRectangle[2] & learner[,3] == trueRectangle[3] & learner[,4] == trueRectangle[4],"posterior"] # extract just the probability of the true rectangle for each
probTrueRect[i] = pointProb
}
# choose the point with the largest probability
maxProb = which.max(probTrueRect) # <-- seems like it's giving the same probability for every positive point and every negative point.
point[j,] = as.matrix(observations[maxProb,1:2])
learnerPrior[,j+1] = learner[,"posterior"] # the learner's prior about the rectangles for the next point is their posterior from the last point
observations = observations[-maxProb,]
}
return(point)
}
test = pedTeacher(cat1,range,nPoints = 3)
View(test)
plot(c(1,max(range)), c(1, max(range)), type = "n", xlab = "", ylab = "", main = "Hypothesis Space, Observations, and True Category Boundary")
rect(cat1[1],cat1[2],cat1[3],cat1[4],border = "red", lwd = 2)
points(test)
