hasPosEvidence = if (length(as.data.frame(posInRect)) > 1) {
apply(posInRect, 1, f)
} else {
# if length is 1, no need to do the above function
hasPosEvidence = posInRect
}
}
negInRect = areInCat(borders, observations, "negative") # does the hypothesised rectangle contain negative evidence?
if (is.na(negInRect[1])) {
hasNegEvidence =  rep(FALSE,length(borders[,1]))
} else {
hasNegEvidence = if (length(as.data.frame(negInRect)) > 1) {
hasNegEvidence = rowSums(negInRect) > 0
} else {
hasNegEvidence = negInRect
}
}
hypotheses = cbind(borders, hasPosEvidence, hasNegEvidence)
hypotheses = hypotheses[hypotheses[, "hasPosEvidence"] == TRUE &
hypotheses[, "hasNegEvidence"] == FALSE, ]
# Pedagogical likelihood --------------------------------------------------------------------------------------------
# Calculate the number of positive and negative observations
if (is.vector(observations)){
numPos = sum(observations["category"]=="positive")
numNeg = sum(observations["category"]=="negative")
} else {
numPos = sum(observations[,"category"]=="positive")
numNeg = sum(observations[,"category"]=="negative")
}
# calculate the area outside of each prospective rectangle (hypothesis)
sizeNeg = findSizeNeg(hypotheses, borderSize = borderSize)
# calculate the area inside of each prospective rectangle (hypothesis)
sizePos = findSize(hypotheses)
s = max(sizePos) # largest eligible hypothesis (following logic that teacher would have chosen negative points that were closer to the poisitive points if the rectangle was smaller)
if (numNeg == 0) {
likelihood = 1/(sizePos^(numPos))
} else {
likelihhod = 1/(s/sizePos)^(sizePos/(numPos+numNeg))
}
posterior = (likelihood*prior)/sum(likelihood*prior)
logLikelihood = log(likelihood)
pedHypotheses = cbind(hypotheses[,1:4], sizePos,sizeNeg,prior,likelihood, likelihoodPos, likelihoodNeg,logLikelihood,posterior)
colnames(pedHypotheses) = c( # <-- rename cols
"x1",
"y1",
"x2",
"y2",
"sizePos",
"sizeNeg",
"prior",
"likelihood",
"likelihoodPos",
"likelihoodNeg",
"logLikelihood",
"posterior"
)
return(pedHypotheses)
}
}
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
library(here)
source(here("functions/heuristic-learner.R"))
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
library(here)
source(here("functions/generic-functions.R"))
source(here("functions/heuristic-learner.R"))
source(here("functions/pedagogical-learner"))
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
library(here)
source(here("functions/generic-functions.R"))
source(here("functions/heuristic-learner.R"))
source(here("functions/pedagogical-learner.R"))
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
library(here)
source(here("functions/generic-functions.R"))
source(here("functions/heuristic-learner.R"))
source(here("functions/pedagogical-learner.R"))
set.seed(123)
# Define range of possible features
range = 1:10
# set up all possible hypotheses
borders = makeBorders(range)
# Define the true category region
trueRectangle = c(2,2,6,8)
#visualize true category region
plot(c(1,max(range)), c(1, max(range)), type= "n", xlab = "", ylab = "")
rect(trueRectangle[1],trueRectangle[2],trueRectangle[3],trueRectangle[4],border = "red", lwd = 3)
obs = sampleRect(5,5,trueRectangle)
# set up different arrays with different numbers of observations
obs1 = obs[c(1,6),]
obs3 = obs[c(1:3,6:9),]
obs5 = obs[c(1:5,6:10),]
# visualize observations
plot(c(1,max(range)), c(1, max(range)), type= "n", xlab = "", ylab = "", main = "Hypothesis Space, Observations, and True Category Boundary")
rect(trueRectangle[1],trueRectangle[2],trueRectangle[3],trueRectangle[4],border = "red", lwd = 2)
points(obs5)
weak1 = pedLearner(borders, obs1, alpha = 0)
weak3 = pedLearner(borders, obs3, alpha = 0)
weak5 = pedLearner(borders, obs5, alpha = 0)
ped1 = pedLearner(borders, obs1)
ped3 = pedLearner(borders, obs3)
ped5 = pedLearner(borders, obs5)
par(mfrow =(c(3,2)))
plot(1:length(ped1[,1]),sort(ped1[,"posterior"]), type = "l")
plot(1:length(weak1[,1]),sort(weak1[,"posterior"]), "l")
plot(1:length(ped5[,1]),sort(ped5[,"posterior"]), type = "l")
plot(1:length(weak5[,1]),sort(weak5[,"posterior"]), "l")
plot(sort(ped1[,"sizePos"]),ped1[sort(ped1[,"sizePos"]),"posterior"], "l")
ls1 = heuristicLearner(borders, obs1)
ls3 = heuristicLearner(borders, obs3)
ls5 = heuristicLearner(borders, obs5)
outer1 = heuristicLearner(borders, obs1, heuristic = "outer")
outer3 = heuristicLearner(borders, obs3, heuristic = "outer")
outer5 = heuristicLearner(borders, obs5, heuristic = "outer")
dec1 = pedLearner(borders, obs1, alpha = -1)
dec3 = pedLearner(borders, obs3, alpha = -1)
dec5 = pedLearner(borders, obs5, alpha = -1)
par(omi=rep(0.3, 4), mar=c(1,1,1,1), mfrow=c(3,4))
plotPed(weak1,obs1,trueRectangle)
mtext("Weak Learner", side = 3)
plotPed(ped1, obs1, trueRectangle)
mtext("Pedegogical Learner", side = 3)
plotHeuristic(ls1, obs1, trueRectangle)
mtext("Least Squares Learner", side = 3)
plotHeuristic(outer1, obs1, trueRectangle)
mtext("Outer Learner", side = 3)
plotPed(weak3,obs3,trueRectangle)
plotPed(ped3, obs3, trueRectangle)
plotHeuristic(ls3, obs3, trueRectangle)
plotHeuristic(outer3, obs3, trueRectangle)
plotPed(weak5,obs5,trueRectangle)
plotPed(ped5, obs5, trueRectangle)
plotHeuristic(ls5, obs5, trueRectangle)
plotHeuristic(outer5, obs5, trueRectangle)
par(omi=rep(0.3, 4), mar=c(1,1,1,1), mfrow=c(3,4))
plotPed(weak1,obs1,trueRectangle,nHypotheses = 3)
mtext("Weak Learner", side = 3)
plotPed(ped1, obs1, trueRectangle, nHypotheses = 3)
mtext("Pedegogical Learner", side = 3)
plotHeuristic(ls1, obs1, trueRectangle, nHypotheses = 3)
mtext("Least Squares Learner", side = 3)
plotHeuristic(outer1, obs1, trueRectangle, nHypotheses = 3)
mtext("Outer Learner", side = 3)
plotPed(weak3,obs3,trueRectangle, nHypotheses = 3)
plotPed(ped3, obs3, trueRectangle, nHypotheses = 3)
plotHeuristic(ls3, obs3, trueRectangle, nHypotheses = 3)
plotHeuristic(outer3, obs3, trueRectangle, nHypotheses = 3)
plotPed(weak5,obs5, trueRectangle, nHypotheses = 3)
plotPed(ped5, obs5, trueRectangle, nHypotheses = 3)
plotHeuristic(ls5, obs5, trueRectangle, nHypotheses = 3)
plotHeuristic(outer5, obs5, trueRectangle, nHypotheses = 3)
par(omi=rep(0.3, 4), mar=c(1,1,1,1), mfrow=c(3,3))
plotPed(dec1, obs1, trueRectangle, nHypotheses = 3)
mtext("Deceptive (alpha = -1)", side = 3)
plotPed(weak1,obs1,trueRectangle,nHypotheses = 3, sampling = "weak")
mtext("Weak (alpha = 0)", side = 3)
plotPed(ped1, obs1, trueRectangle, nHypotheses = 3)
mtext("Helpful (alpha = 1)", side = 3)
plotPed(dec3, obs3, trueRectangle, nHypotheses = 3)
plotPed(weak3,obs3,trueRectangle, nHypotheses = 3, sampling = "weak")
plotPed(ped3, obs3, trueRectangle, nHypotheses = 3)
plotPed(dec5, obs5, trueRectangle, nHypotheses = 3)
plotPed(weak5,obs5, trueRectangle, nHypotheses = 3, sampling = "weak")
plotPed(ped5, obs5, trueRectangle, nHypotheses = 3)
obs1Pos = c(4,4,"positive")
names(obs1Pos) = c("x","y","category")
obs1Neg = c(8,8,"negative")
names(obs1Neg) = c("x","y","category")
ped1Pos = pedLearner(borders,obs1Pos)
ped1Neg = pedLearner(borders,obs1Neg)
par(omi=rep(0.3, 4), mar=c(1,1,1,1), mfrow=c(1,2))
plotPed(ped1Neg,obs1Neg,trueRectangle, nHypotheses = 3)
plotPed(ped1Pos,obs1Pos,trueRectangle, nHypotheses = 3)
knitr::opts_chunk$set(echo = TRUE)
library(here)
source(here("functions/generic-functions.R"))
source(here("new-ped-learner.R"))
obs = load("obsTest.Rdata")
obs = load("obsTest.Rdata")
View(obs1)
load("~/Documents/Projects/RectangleWorld-sims/obsTest.Rdata")
View(obs)
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE)
library(here)
source(here("functions/generic-functions.R"))
source(here("new-ped-learner.R"))
load("obsTest.Rdata")
obs1 = obs[,"nObsCond" == 1]
obs2 = obs[,"nObsCond" == 2]
View(obs2)
View(obs1)
obs1 = obs[obs[,"nObsCond"] == 1,]
obs2 = obs[obs[,"nObsCond"] == 2,]
View(obs2)
obs1
borders = makeBorders(0:10)
newPedLearner = function(borders, observations, alpha = 1) {
# set up default prior if no other is specified
prior = ifelse(prior == "uniform", rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))), prior)
# Rule out ineligible rectangles ----------------------------------------------------------------------
posInRect = areInCat(borders, observations, "positive")
if (is.na(posInRect[1])) {
hasPosEvidence = rep(TRUE,length(borders[,1])) # if there is no positive evidence, then all of the hypotheses are valid for this condition
} else { f = function(isInRect) setequal(isInRect, rep(TRUE, length(as.data.frame(isInRect)))) # make isInRect a function suitable for apply
# Find out which rectangles contain positive evidence
hasPosEvidence = if (length(as.data.frame(posInRect)) > 1) {
apply(posInRect, 1, f)
} else {
# if length is 1, no need to do the above function
hasPosEvidence = posInRect
}
}
negInRect = areInCat(borders, observations, "negative") # does the hypothesised rectangle contain negative evidence?
if (is.na(negInRect[1])) {
hasNegEvidence =  rep(FALSE,length(borders[,1]))
} else {
hasNegEvidence = if (length(as.data.frame(negInRect)) > 1) {
hasNegEvidence = rowSums(negInRect) > 0
} else {
hasNegEvidence = negInRect
}
}
hypotheses = cbind(borders, hasPosEvidence, hasNegEvidence)
hypotheses = hypotheses[hypotheses[, "hasPosEvidence"] == TRUE &
hypotheses[, "hasNegEvidence"] == FALSE, ]
# Pedagogical likelihood --------------------------------------------------------------------------------------------
# Calculate the number of positive and negative observations
if (is.vector(observations)){
numPos = sum(observations["category"]=="positive")
numNeg = sum(observations["category"]=="negative")
} else {
numPos = sum(observations[,"category"]=="positive")
numNeg = sum(observations[,"category"]=="negative")
}
# calculate the area outside of each prospective rectangle (hypothesis)
sizeNeg = findSizeNeg(hypotheses, borderSize = borderSize)
# calculate the area inside of each prospective rectangle (hypothesis)
sizePos = findSize(hypotheses)
s = max(sizePos) # largest eligible hypothesis (following logic that teacher would have chosen negative points that were closer to the poisitive points if the rectangle was smaller)
if (numNeg == 0) {
likelihood = 1/(sizePos^(numPos))
} else {
likelihhod = 1/(s/sizePos)^(sizePos/(numPos+numNeg))
}
posterior = (likelihood*prior)/sum(likelihood*prior)
logLikelihood = log(likelihood)
pedHypotheses = cbind(hypotheses[,1:4], sizePos,sizeNeg,prior,likelihood, likelihoodPos, likelihoodNeg,logLikelihood,posterior)
colnames(pedHypotheses) = c( # <-- rename cols
"x1",
"y1",
"x2",
"y2",
"sizePos",
"sizeNeg",
"prior",
"likelihood",
"likelihoodPos",
"likelihoodNeg",
"logLikelihood",
"posterior"
)
return(pedHypotheses)
}
ped1 = newPedLearner(borders, obs1)
newPedLearner = function(borders, observations, alpha = 1, prior = "uniform") {
# set up default prior if no other is specified
prior = ifelse(prior == "uniform", rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))), prior)
# Rule out ineligible rectangles ----------------------------------------------------------------------
posInRect = areInCat(borders, observations, "positive")
if (is.na(posInRect[1])) {
hasPosEvidence = rep(TRUE,length(borders[,1])) # if there is no positive evidence, then all of the hypotheses are valid for this condition
} else { f = function(isInRect) setequal(isInRect, rep(TRUE, length(as.data.frame(isInRect)))) # make isInRect a function suitable for apply
# Find out which rectangles contain positive evidence
hasPosEvidence = if (length(as.data.frame(posInRect)) > 1) {
apply(posInRect, 1, f)
} else {
# if length is 1, no need to do the above function
hasPosEvidence = posInRect
}
}
negInRect = areInCat(borders, observations, "negative") # does the hypothesised rectangle contain negative evidence?
if (is.na(negInRect[1])) {
hasNegEvidence =  rep(FALSE,length(borders[,1]))
} else {
hasNegEvidence = if (length(as.data.frame(negInRect)) > 1) {
hasNegEvidence = rowSums(negInRect) > 0
} else {
hasNegEvidence = negInRect
}
}
hypotheses = cbind(borders, hasPosEvidence, hasNegEvidence)
hypotheses = hypotheses[hypotheses[, "hasPosEvidence"] == TRUE &
hypotheses[, "hasNegEvidence"] == FALSE, ]
# Pedagogical likelihood --------------------------------------------------------------------------------------------
# Calculate the number of positive and negative observations
if (is.vector(observations)){
numPos = sum(observations["category"]=="positive")
numNeg = sum(observations["category"]=="negative")
} else {
numPos = sum(observations[,"category"]=="positive")
numNeg = sum(observations[,"category"]=="negative")
}
# calculate the area outside of each prospective rectangle (hypothesis)
sizeNeg = findSizeNeg(hypotheses, borderSize = borderSize)
# calculate the area inside of each prospective rectangle (hypothesis)
sizePos = findSize(hypotheses)
s = max(sizePos) # largest eligible hypothesis (following logic that teacher would have chosen negative points that were closer to the poisitive points if the rectangle was smaller)
if (numNeg == 0) {
likelihood = 1/(sizePos^(numPos))
} else {
likelihhod = 1/(s/sizePos)^(sizePos/(numPos+numNeg))
}
posterior = (likelihood*prior)/sum(likelihood*prior)
logLikelihood = log(likelihood)
pedHypotheses = cbind(hypotheses[,1:4], sizePos,sizeNeg,prior,likelihood, likelihoodPos, likelihoodNeg,logLikelihood,posterior)
colnames(pedHypotheses) = c( # <-- rename cols
"x1",
"y1",
"x2",
"y2",
"sizePos",
"sizeNeg",
"prior",
"likelihood",
"likelihoodPos",
"likelihoodNeg",
"logLikelihood",
"posterior"
)
return(pedHypotheses)
}
ped1 = newPedLearner(borders, obs1)
newPedLearner = function(borders, observations, alpha = 1, prior = "uniform", bordersSize = 100) {
# set up default prior if no other is specified
prior = ifelse(prior == "uniform", rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))), prior)
# Rule out ineligible rectangles ----------------------------------------------------------------------
posInRect = areInCat(borders, observations, "positive")
if (is.na(posInRect[1])) {
hasPosEvidence = rep(TRUE,length(borders[,1])) # if there is no positive evidence, then all of the hypotheses are valid for this condition
} else { f = function(isInRect) setequal(isInRect, rep(TRUE, length(as.data.frame(isInRect)))) # make isInRect a function suitable for apply
# Find out which rectangles contain positive evidence
hasPosEvidence = if (length(as.data.frame(posInRect)) > 1) {
apply(posInRect, 1, f)
} else {
# if length is 1, no need to do the above function
hasPosEvidence = posInRect
}
}
negInRect = areInCat(borders, observations, "negative") # does the hypothesised rectangle contain negative evidence?
if (is.na(negInRect[1])) {
hasNegEvidence =  rep(FALSE,length(borders[,1]))
} else {
hasNegEvidence = if (length(as.data.frame(negInRect)) > 1) {
hasNegEvidence = rowSums(negInRect) > 0
} else {
hasNegEvidence = negInRect
}
}
hypotheses = cbind(borders, hasPosEvidence, hasNegEvidence)
hypotheses = hypotheses[hypotheses[, "hasPosEvidence"] == TRUE &
hypotheses[, "hasNegEvidence"] == FALSE, ]
# Pedagogical likelihood --------------------------------------------------------------------------------------------
# Calculate the number of positive and negative observations
if (is.vector(observations)){
numPos = sum(observations["category"]=="positive")
numNeg = sum(observations["category"]=="negative")
} else {
numPos = sum(observations[,"category"]=="positive")
numNeg = sum(observations[,"category"]=="negative")
}
# calculate the area outside of each prospective rectangle (hypothesis)
sizeNeg = findSizeNeg(hypotheses, borderSize = borderSize)
# calculate the area inside of each prospective rectangle (hypothesis)
sizePos = findSize(hypotheses)
s = max(sizePos) # largest eligible hypothesis (following logic that teacher would have chosen negative points that were closer to the poisitive points if the rectangle was smaller)
if (numNeg == 0) {
likelihood = 1/(sizePos^(numPos))
} else {
likelihhod = 1/(s/sizePos)^(sizePos/(numPos+numNeg))
}
posterior = (likelihood*prior)/sum(likelihood*prior)
logLikelihood = log(likelihood)
pedHypotheses = cbind(hypotheses[,1:4], sizePos,sizeNeg,prior,likelihood, likelihoodPos, likelihoodNeg,logLikelihood,posterior)
colnames(pedHypotheses) = c( # <-- rename cols
"x1",
"y1",
"x2",
"y2",
"sizePos",
"sizeNeg",
"prior",
"likelihood",
"likelihoodPos",
"likelihoodNeg",
"logLikelihood",
"posterior"
)
return(pedHypotheses)
}
ped1 = newPedLearner(borders, obs1)
newPedLearner = function(borders, observations, alpha = 1, prior = "uniform", borderSize = 100) {
# set up default prior if no other is specified
prior = ifelse(prior == "uniform", rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))), prior)
# Rule out ineligible rectangles ----------------------------------------------------------------------
posInRect = areInCat(borders, observations, "positive")
if (is.na(posInRect[1])) {
hasPosEvidence = rep(TRUE,length(borders[,1])) # if there is no positive evidence, then all of the hypotheses are valid for this condition
} else { f = function(isInRect) setequal(isInRect, rep(TRUE, length(as.data.frame(isInRect)))) # make isInRect a function suitable for apply
# Find out which rectangles contain positive evidence
hasPosEvidence = if (length(as.data.frame(posInRect)) > 1) {
apply(posInRect, 1, f)
} else {
# if length is 1, no need to do the above function
hasPosEvidence = posInRect
}
}
negInRect = areInCat(borders, observations, "negative") # does the hypothesised rectangle contain negative evidence?
if (is.na(negInRect[1])) {
hasNegEvidence =  rep(FALSE,length(borders[,1]))
} else {
hasNegEvidence = if (length(as.data.frame(negInRect)) > 1) {
hasNegEvidence = rowSums(negInRect) > 0
} else {
hasNegEvidence = negInRect
}
}
hypotheses = cbind(borders, hasPosEvidence, hasNegEvidence)
hypotheses = hypotheses[hypotheses[, "hasPosEvidence"] == TRUE &
hypotheses[, "hasNegEvidence"] == FALSE, ]
# Pedagogical likelihood --------------------------------------------------------------------------------------------
# Calculate the number of positive and negative observations
if (is.vector(observations)){
numPos = sum(observations["category"]=="positive")
numNeg = sum(observations["category"]=="negative")
} else {
numPos = sum(observations[,"category"]=="positive")
numNeg = sum(observations[,"category"]=="negative")
}
# calculate the area outside of each prospective rectangle (hypothesis)
sizeNeg = findSizeNeg(hypotheses, borderSize = borderSize)
# calculate the area inside of each prospective rectangle (hypothesis)
sizePos = findSize(hypotheses)
s = max(sizePos) # largest eligible hypothesis (following logic that teacher would have chosen negative points that were closer to the poisitive points if the rectangle was smaller)
if (numNeg == 0) {
likelihood = 1/(sizePos^(numPos))
} else {
likelihhod = 1/(s/sizePos)^(sizePos/(numPos+numNeg))
}
posterior = (likelihood*prior)/sum(likelihood*prior)
logLikelihood = log(likelihood)
pedHypotheses = cbind(hypotheses[,1:4], sizePos,sizeNeg,prior,likelihood, likelihoodPos, likelihoodNeg,logLikelihood,posterior)
colnames(pedHypotheses) = c( # <-- rename cols
"x1",
"y1",
"x2",
"y2",
"sizePos",
"sizeNeg",
"prior",
"likelihood",
"likelihoodPos",
"likelihoodNeg",
"logLikelihood",
"posterior"
)
return(pedHypotheses)
}
ped1 = newPedLearner(borders, obs1)
source("~/Documents/Projects/RectangleWorld-sims/new-ped-learner.R", echo=TRUE)
ped1 = newPedLearner(borders, obs1)
View(ped1)
ped2 = newPedLearner(borders, obs2)
source("~/Documents/Projects/RectangleWorld-sims/new-ped-learner.R", echo=TRUE)
ped2 = newPedLearner(borders, obs2)
View(ped2)
source(here("functions/pedagogical-learner.R"))
View(plotPed)
plotPed(ped1, obs1, c(1,1,1,1), nHypotheses = 1)
plot(obs1)
plot(obs1[,1:2])
plot(obs1[1:2])
plot(obs1[1:2], xlim = c(0,10), ylim = c(0,10))
obs1
plot(obs1[1], obs[2]], xlim = c(0,10), ylim = c(0,10))
plot(obs1[1], obs[2], xlim = c(0,10), ylim = c(0,10))
plot(obs2[,1], obs2[,2], xlim = c(0,10), ylim = c(0,10))
ped1[sort(ped1[,"posterior"], decreasing = TRUE),]
sort(ped1[,"posterior"], decreasing = TRUE)
order(ped1[,"posterior"], decreasing = TRUE)
ped1[order(ped1[,"posterior"], decreasing = TRUE),]
ped1Best = ped1[order(ped1[,"posterior"], decreasing = TRUE),][1,]
ped1Best
ped1Best[1]
rect(ped1Best[1], ped1Best[2], ped1Best[3], ped1Best[4])
plot(obs1[1], obs[2], xlim = c(0,10), ylim = c(0,10))
rect(ped1Best[1], ped1Best[2], ped1Best[3], ped1Best[4])
plot(obs1[1], obs[2], xlim = c(0,10), ylim = c(0,10))
rect(ped1Best[1], ped1Best[2], ped1Best[3], ped1Best[4])
plot(obs1[1], obs1[2], xlim = c(0,10), ylim = c(0,10))
rect(ped1Best[1], ped1Best[2], ped1Best[3], ped1Best[4])
plot(obs1[1], obs1[2], xlim = c(0,10), ylim = c(0,10))
rect(ped1Best[1], ped1Best[2], ped1Best[3], ped1Best[4])
ped2Best = ped2[order(ped2[,"posterior"], decreasing = TRUE),][1,]
ped2Best
rect(ped2Best[1], ped2Best[2], ped2Best[3], ped2Best[4])
plot(obs2[,1], obs2[,2], xlim = c(0,10), ylim = c(0,10))
rect(ped2Best[1], ped2Best[2], ped2Best[3], ped2Best[4])
