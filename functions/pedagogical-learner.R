### Pedagogical Learner ###
source("functions/generic-functions.R")

isInRectangle <- function (p,r) {
  return (p[1]>=r[1] & p[1]<=r[3] & p[2]>=r[2] & p[2]<=r[4])
}


#' Simulates a learner who assumes observations are sampled pedagogically
#'  
#' @param alpha Numeric value from -inf to inf. determines how helpful the learner thinks the teacher is. Alpha = 0 is equivalent to weak sampling, alpha = 1 is standard pedagogical sampling. 
#' @param borders Array of hypothesised category boundary points (coordinates of rectangles)
#' @param observations Points that have been labelled as belonging to a certain category
#' @param prior Numeric vector of the same length as borders. Default is a uniform prior. 
pedLearner = function(borders, observations, prior = "uniform", alpha = 1) {
  
  prior = ifelse(prior == "uniform", rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1]))), prior)
  
  # if (prior == "uniform"){
  #   prior = rep(1,length(borders[,1]))/sum(rep(1,length(borders[,1])))
  # } else {
  #   prior = prior
  # }
  
  posInRect = areInCat(borders, observations, "positive")
  
  if (is.na(posInRect[1])) {
    hasPosEvidence = rep(TRUE,length(borders[,1])) # if there is no positive evidence, then all of the hypotheses are valid for this condition
  } else { f = function(isInRect) setequal(isInRect, rep(TRUE, length(as.data.frame(isInRect)))) # make isInRect a function suitable for apply
  # Find out which rectangles contain positive evidence
  hasPosEvidence = if (length(as.data.frame(posInRect)) > 1) {     
    apply(posInRect, 1, f)
  } else {
    # if length is 1, no need to do the above function
    hasPosEvidence = posInRect
  }
    
  }
  
  negInRect = areInCat(borders, observations, "negative") # does the hypothesised rectangle contain negative evidence?
  if (is.na(negInRect[1])) {
    hasNegEvidence =  rep(FALSE,length(borders[,1]))
  } else {  
    hasNegEvidence = if (length(as.data.frame(negInRect)) > 1) {
    hasNegEvidence = rowSums(negInRect) > 0
  } else {
    hasNegEvidence = negInRect
  }
    
  }
  
  hypotheses = cbind(borders, hasPosEvidence, hasNegEvidence)
  hypotheses = hypotheses[hypotheses[, "hasPosEvidence"] == TRUE &
                            hypotheses[, "hasNegEvidence"] == FALSE, ]
  
### pedagogical likelihood

  if (is.vector(observations)){
    numPos = sum(observations["category"]=="positive")
    numNeg = sum(observations["category"]=="negative")
  } else {
    numPos = sum(observations[,"category"]=="positive")
    numNeg = sum(observations[,"category"]=="negative")
  }
  
  sizeNeg = findSizeNeg(hypotheses) # likelihood for negative evidence is different to positive evidence
  sizePos = findSize(hypotheses)
  
  likelihoodNeg = (1 / findSizeNeg(hypotheses) ^ numNeg) 
  likelihoodPos = (1 / findSize(hypotheses) ^ numPos) # non-log probability so that I can integrate it with alpha/transparency when plotting
  likelihood = (likelihoodNeg*likelihoodPos)^alpha
  
  posterior = (likelihood*prior)/sum(likelihood*prior)
  
  logLikelihood = log(likelihood)
  
  pedHypotheses = cbind(hypotheses[,1:6], sizePos,sizeNeg,prior,likelihood, likelihoodPos, likelihoodNeg,logLikelihood,posterior)
  
  colnames(pedHypotheses) = c( # <-- matrix columns messed up 
    "x1",
    "y1",
    "x2",
    "y2",
    "hasPosEvidence",
    "hasNegEvidence",
    "sizePos",
    "sizeNeg",
    "prior",
    "likelihood",
    "likelihoodPos",
    "likelihoodNeg",
    "logLikelihood",
    "posterior"
  )
  return(pedHypotheses)
}

#' Plot predictions of the pedagogical learner
plotPed = function(hypotheses, #' @param hypotheses Matrix including the posterior probability of each rectangle and their coordinates as generated by the pedLearner function. 
                   observations, #' @param observations Matrix (or vector if only one point) of points that have been labeled as belonging to the true category or not (same input as pedLearner)
                   trueRectangle,#' @param trueRectangle True rectangle 
                   range = 1:10, #' @param range Vector denoting the size of hypothesis space and discrete intervals
                   nHypotheses = "all", #' @param nHypotheses Number of hypotheses/rectangles to plot. E.g., nHypotheses = 1 means only the most probable rectangle is plotted. 
                   sampling = "ped"){ 
  
  if (nHypotheses == "all"){
    nHypotheses = length(hypotheses[,1])
  } else {
    nHypotheses = nHypotheses
  }
  
   if (sampling == "weak") {
     randomHyp = sample(1:length(hypotheses[,1]), size = nHypotheses)
     hypotheses = hypotheses[randomHyp,]
   } 
  
  
  hypotheses = hypotheses[order(hypotheses[,"posterior"], decreasing = TRUE),]
  hypotheses = hypotheses[1:nHypotheses,]
  hypotheses[,"posterior"] = hypotheses[,"posterior"]/sum(hypotheses[,"posterior"])
  
  if (is.vector(observations)){ # plotting syntax is slightly different when there's only 1 observation (i.e., it's a vector)
    plot(c(1,max(range)), c(1, max(range)), type= "n", xlab = "", ylab = "")
    rect(hypotheses[,1],hypotheses[,2],hypotheses[,3],hypotheses[,4], col= rgb(0,0,1.0,alpha=hypotheses[,"posterior"]), lwd = 0.01) # making alpha equivalent to the likelihood generalization gradient 
    points(observations[1], observations[2]) # this part is different when observations is a vector
    rect(trueRectangle[1],trueRectangle[2],trueRectangle[3],trueRectangle[4],border = "red", lwd = 2)
  } else{
    plot(c(1,max(range)), c(1, max(range)), type= "n", xlab = "", ylab = "")
    rect(hypotheses[,1],hypotheses[,2],hypotheses[,3],hypotheses[,4], col= rgb(0,0,1.0,alpha=hypotheses[,"posterior"]), lwd = 0.01) 
    points(observations)
    rect(trueRectangle[1],trueRectangle[2],trueRectangle[3],trueRectangle[4],border = "red", lwd = 2)
  }
  
}


